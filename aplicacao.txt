/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Bot.hpp                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: caalbert <caalbert@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/27 11:31:32 by caalbert          #+#    #+#             */
/*   Updated: 2024/05/27 11:31:50 by caalbert         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef BOTCOMMANDS_HPP
#define BOTCOMMANDS_HPP

#include "Server.hpp"

class BotCommands {
public:
    static void handle_marvin(Server &server, const std::string &buffer, int fd);
    static void handle_time(Server &server, const std::string &buffer, int fd);
    static void handle_whois(Server &server, const std::string &buffer, int fd);
};

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Replies.hpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/11 18:18:57 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 20:30:59 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef REPLIES_HPP
# define REPLIES_HPP

# define CRLF "\r\n"

// refer to https://datatracker.ietf.org/doc/html/rfc1459

# define RPL_CONNECTED(nickname) (": 001 " + nickname + " : Welcome to the IRC server!" + CRLF)

# define RPL_UMODEIS(hostname, channelname, mode, user)  ":" + hostname + " MODE " + channelname + " " + mode + " " + user + CRLF

# define RPL_CREATIONTIME(nickname, channelname, creationtime) ": 329 " + nickname + " " + channelname + " " + creationtime + CRLF

# define RPL_CHANNELMODES(nickname, channelname, modes) ": 324 " + nickname + " " + channelname + " " + modes + CRLF

# define RPL_CHANGEMODE(hostname, channelname, mode, arguments) (":" + hostname + " MODE " + channelname + " " + mode + " " + arguments + CRLF)

# define RPL_NICKCHANGE(oldnickname, nickname) (":" + oldnickname + " NICK " + nickname + CRLF)

# define RPL_JOINMSG(hostname, ipaddress, channelname) (":" + hostname + "@" + ipaddress + " JOIN " + channelname + CRLF)

# define RPL_NAMREPLY(nickname, channelname, clientslist) (": 353 " + nickname + " @ " + channelname + " :" + clientslist + CRLF)

# define RPL_ENDOFNAMES(nickname, channelname) (": 366 " + nickname + " " + channelname + " :END of /NAMES list" + CRLF)

// Topic
# define RPL_TOPIC(nickname, channelname, topic) (": 332 " + nickname + " " +channelname + " :" + topic + CRLF)
# define RPL_NOTOPIC(nickname, channelname) (": 331 " + nickname + " " +channelname + " : No topic is set " + CRLF)

# define RPL_QUITMESSAGE(nickname) (": 301 " + nickname + " :You have quit the server." + CRLF)
# define RPL_PART(hostname, channelname, nickname) (":" + hostname + " PART " + channelname + " :" + nickname + " has left the channel" + CRLF)
# define RPL_KICK(hostname, channelname, kickername, kickedname, comment) (":" + hostname + " KICK " + channelname + " " + kickedname + " :" + kickername + " " + comment + CRLF)
# define RPL_INVITING(hostname, channelname, invitername, invitedname) (":" + hostname + " INVITE " + invitedname + " " + channelname + CRLF)
# define RPL_PRIVMSG(hostname, receiver, text) (":" + hostname + " PRIVMSG " + receiver + " " + text + CRLF)

///////// ERRORS /////////
# define ERR_NEEDMODEPARM(channelname, mode) (": 696 " + channelname + " * You must specify a parameter for the key mode. " + mode + CRLF)
# define ERR_INVALIDMODEPARM(channelname, mode) (": 696 " + channelname + " Invalid mode parameter. " + mode + CRLF)
# define ERR_KEYSET(channelname) ": 467 " + channelname + " Channel key already set. " + CRLF
# define ERR_UNKNOWNMODE(nickname, channelname, mode) ": 472 " + nickname + " " + channelname + " " + mode + " :is not a recognised channel mode" + CRLF
# define ERR_NEEDMOREPARAMS(nickname) (": 461 " + nickname + " :Not enough parameters." + CRLF)
# define ERR_CHANNELNOTFOUND(nickname, channelname) (": 403 " + nickname + " " + channelname + " :No such channel" + CRLF)
# define ERR_NOTOPERATOR(channelname) (": 482 " + channelname + " :You're not a channel operator" + CRLF)
# define ERR_NOSUCHNICK(channelname, name) (": 401 " + channelname + " " + name + " :No such nick/channel" + CRLF )
# define ERR_INCORPASS(nickname) (": 464 " + nickname + " :Password incorrect !" + CRLF )
# define ERR_NONICKNAME(nickname) (": 431 " + nickname + " :No nickname given" + CRLF )
# define ERR_NICKINUSE(nickname) (": 433 " + nickname + " :Nickname is already in use" + CRLF)
# define ERR_ERRONEUSNICK(nickname) (": 432 " + nickname + " :Erroneus nickname" + CRLF)


# define ERR_ALREADYREGISTERED(nickname) (": 462 " + nickname + " :You may not reregister !" + CRLF )
# define ERR_NOTREGISTERED(nickname) (": 451 " + nickname + " :You have not registered!" + CRLF)

# define ERR_CMDNOTFOUND(nickname, command) (": 421 " + nickname + " " + command + " :Unknown command" + CRLF)

# define ERR_BADCHANNELKEY(clientnickname, channelname) (": 475 " + clientnickname + " " + channelname + " :Cannot join channel (incorrect key)" + CRLF)
# define ERR_INVITEONLYCHAN(clientnickname, channelname) (": 473 " + clientnickname + " " + channelname + " :Cannot join channel (+i)" + CRLF)
# define ERR_CHANNELISFULL(clientnickname, channelname) (": 422 " + clientnickname + " " + channelname + " :Cannot join channel (+l)" + CRLF)
# define ERR_NOSUCHCHANNEL(channelname) (": 403 " + channelname + " :No such channel" + CRLF)
# define ERR_USERNOTINCHANNEL(nickname, channelname) ("441 " + nickname + " " + channelname + " :They aren't on that channel" + CRLF)
# define ERR_NOTONCHANNEL(channelname) (": 442 " + channelname + " :You're not on that channel" + CRLF)
# define ERR_USERONCHANNEL(user, channelname) (": 443 " + user + " " + channelname + " :is already on channel" + CRLF) 
# define ERR_CHANOPRIVSNEEDED(channelname) (": 482 " + channelname + " :You're not a channel operator" + CRLF)
# define ERR_NOPRIVILEGES(nickname) (": 481 " + nickname + " :Permission Denied- You're not an IRC operator" + CRLF)

#endif // REPLIES_HPP
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: caalbert <caalbert@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/28 10:23:47 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/27 19:14:06 by caalbert         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SERVER_HPP
# define SERVER_HPP

# include <string> // Para std::to_string
# include <cstring>
# include <cstdlib> // para a função std::atoi
# include <iostream>
# include <vector> //-> for vector
# include <sys/socket.h> //-> for socket()
# include <sys/types.h> //-> for socket()
# include <netinet/in.h> //-> for sockaddr_in
# include <fcntl.h> //-> for fcntl()
# include <unistd.h> //-> for close()
# include <arpa/inet.h> //-> for inet_ntoa()
# include <poll.h> //-> for poll()
# include <csignal> //-> for signal()
# include <sstream> //-> for std::stringstream
# include <iomanip>
# include <map> //-> for map

//-------------------------------------------------------//
# define RED "\e[1;31m" //-> for red color
# define WHI "\e[0;37m" //-> for white color
# define GRE "\e[1;32m" //-> for green color
# define YEL "\e[1;33m" //-> for yellow color
//-------------------------------------------------------//

# include "Client.hpp" //-> for client class
# include "Replies.hpp" //-> for replies class
# include "Channel.hpp" //-> for channel class

# define SPACE " "
# define CRLF "\r\n"
# define LINE_FEED "\n"
# define DELIMITER " \t"

class Server
{
	public:
		Server();
		~Server();
		// This contructor is to be used as a workaround for mockup tests
		Server(std::string password, std::vector<Client> _clients, std::vector<Channel> _channels);

		void init(const std::string &port, const std::string &password);
		Client* get_client(int fd);
		void send_response(int fd, const std::string& message);

	private:
		int _port; //-> server port
		int _server_fdsocket; //-> server socket file descriptor
		std::string _password; //-> server password
		std::vector<Client> _clients; //-> vector of clients
		std::vector<struct pollfd> _fds; //-> vector of pollfd
		struct sockaddr_in _server_addr; //-> server address
		std::vector<Channel *> _channels; //-> vector of channels

		int _reply_code; // -> This a workaround to test the IRC commands without mocking up a client-server connection

		int get_reply_code(void); // -> Get the reply code to be checked against criterion test results
		void _is_valid_port(const std::string &port);
		bool _is_valid_nickname(const std::string &nickname);
		bool _is_nickname_in_use(const int fd, const std::string &nickname);

		void _handler_client_join(const std::string &buffer, const int fd);
		void _handler_client_quit(const std::string &buffer, const int fd);
		void _handler_client_part(const std::string &buffer, const int fd);
		void _handler_client_mode(const std::string &buffer, const int fd);
		void _handler_client_kick(const std::string &buffer, const int fd);
		void _handler_client_topic(const std::string &buffer, const int fd);
		void _handler_client_invite(const std::string &buffer, const int fd);
		void _handler_client_privmsg(const std::string &buffer, const int fd);
		void _handler_client_nickname(const std::string &nickname, const int fd);
		void _handler_client_username(const std::string &username, const int fd);
		void _handler_client_password(const std::string &password, const int fd);
		void _handle_marvin(const std::string &buffer, int fd);
		void _handle_time(const std::string &buffer, int fd);
		void _handle_whois(const std::string &buffer, int fd);

		static bool _signal; //-> static boolean for signal
		static void _signal_handler(const int signum);

		void _server_loop(); //-> server loop
		void _set_server_socket(); //-> server socket creation
		void _add_server_signal(); //-> server signal creation
		void _accept_new_client(); //-> accept new client
		void _clear_client(const int fd); //-> clear clients
		void _receive_new_data(const int fd); //-> receive data from a client
		void _send_response(const int fd, const std::string &response); //-> send response to client

		struct command_handler
		{
			std::string command;
			void (Server::*handler)(const std::string &, const int);
		};

		static const int _command_list_size = 15; //-> command list size
		static const command_handler _command_list[_command_list_size]; //-> command list
		void _execute_command(const std::string buffer, const int fd); //-> execute command

		std::string _cleanse_buffer(const std::string &buffer, const std::string &chars_to_remove); //-> parse received buffer
		std::vector<std::string> _split_buffer(const std::string &buffer, const std::string &delimiter); //-> split string

		Client* _get_client(const int fd); //-> get client
		Client* _get_client(const std::string nickname); // -> get nickname
		bool _client_is_ready_to_login(const int fd);

		Channel* _get_channel(const std::string &channel_name); //-> get channel

		void _close_fds(); //-> close file descriptors

		void _add_channel(Channel *channel); // -> add a new channel to server channels

		std::string toupper(const std::string& str);
};


#endif // SERVER_HPP/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Channel.hpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:24:04 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 22:19:57 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CHANNEL_HPP
# define CHANNEL_HPP

# include "Client.hpp"
# include "Replies.hpp"
		
class Channel
{
	public:
		Channel();
		~Channel();
		Channel(std::string name);

		int get_clients_size(void) const;
		std::string get_name(void) const;
		std::string get_topic(void) const;
		std::string get_channel_key(void) const;
		std::string get_client_names(void) const;
		std::vector<Client *> get_channel_clients(void);
		std::vector<Client *> get_operator_clients(void);


		void set_limit(int limit);
		void set_invite_only(void);
		void set_topic_restriction(void);
		void set_topic(std::string topic);
		void set_key(std::string password);
		void set_channel_operator(Client *client);

		void remove_key(void);
		void remove_limit(void);
		void remove_invite_only(void);
		void remove_topic_restriction(void);
		void remove_channel_operator(Client *client);
		
		void invite(Client *client);
		void join(Client *client);
		void kick(Client *client);
		void part(Client *client);
		void broadcast(Client *sender, std::string command, std::string target, std::string message);
		
		bool has_key(void) const;
		bool has_client(Client *client);
		
		bool is_channel_full(void) const;
		bool is_channel_invite_only(void) const;
		bool is_channel_operator(std::string nickname);
		bool is_client_in_channel(std::string nickname);

	private:
		int _limit;
		std::string _key;
		std::string _name;
		bool _invite_only;
		std::string _topic;
		bool _topic_restriction;
		std::string _created_at;
		
		bool _has_password;
		bool _has_key;
		std::vector<Client *>_clients;  // -> list of clients that are channel members
		std::vector<Client *>_operator_clients;  // -> list of channel operators
};

#endif //CHANNEL_HPP/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Client.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: caalbert <caalbert@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/28 10:19:06 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/27 19:12:32 by caalbert         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CLIENT_HPP
# define CLIENT_HPP

# include <iostream>
# include <vector> //-> for vector
# include <sys/socket.h> //-> for socket()
# include <sys/types.h> //-> for socket()
# include <netinet/in.h> //-> for sockaddr_in
# include <fcntl.h> //-> for fcntl()
# include <unistd.h> //-> for close()
# include <arpa/inet.h> //-> for inet_ntoa()
# include <poll.h> //-> for poll()
# include <csignal> //-> for signal()
# include <string>
# include <algorithm>
# include "Replies.hpp"

//-------------------------------------------------------//
# define RED "\e[1;31m" //-> for red color
# define WHI "\e[0;37m" //-> for white color
# define GRE "\e[1;32m" //-> for green color
# define YEL "\e[1;33m" //-> for yellow color
//-------------------------------------------------------//

class Client //-> class for client
{
	public:
		Client();

		int get_fd() const;
		bool get_is_logged() const;
		std::string get_buffer() const;
		std::string get_nickname() const;
		std::string get_username() const;
		std::string get_password() const;
		std::string get_hostname() const;
		std::string get_ip_address() const;
		bool get_is_authenticated() const;
		bool get_is_operator() const;

		void set_fd(const int fd);
		void set_is_logged(bool is_logged);
		void set_ip_add(const std::string &ipadd);
		void set_buffer(const std::string &buffer);
		void set_nickname(const std::string &nickname);
		void set_username(const std::string &username);
		void set_password(const std::string &password);
		void set_is_authenticated(bool is_authenticated);
		void set_is_operator(bool is_operator);

		bool is_channel_invited(const std::string &channel);
		void add_channel_invited(const std::string &channel);

		void broadcast(Client *sender, std::string command, std::string target, std::string message);

	private:
		int _fd; //-> client file descriptor
		bool _is_logged; //-> boolean for login
		std::string _buffer; //-> client buffer
		bool _is_authenticated; //-> boolean for authentication
		bool _is_operator; //-> boolean for channel operator
		std::string _ip_addr; //-> client ip address
		std::string _nickname; //-> client nickname
		std::string _username; //-> client username
		std::string _password; //-> client password
		std::vector<std::string> _channels_invited; //-> vector of channels invited
};

std::string Client::get_ip_address() const {
	return _ip_addr;
}

#endif // CLIENT_HPP/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Utils.cpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yde-goes <yde-goes@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/24 18:02:52 by yde-goes          #+#    #+#             */
/*   Updated: 2024/05/24 18:27:47 by yde-goes         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Utils.hpp"

#include <vector>
#include <string>
#include <sstream>
#include <utility>

std::pair<std::vector<std::string>, std::string> split_message(const std::string& message) {
	std::istringstream iss(message);
	std::string receiversStr, text;

	// Get the receivers string and the text
	std::getline(iss, receiversStr, ' ');
	std::getline(iss, text);

	// Split the receivers string into individual receivers
	std::vector<std::string> receivers;
	std::istringstream receiversStream(receiversStr);
	std::string receiver;
	while (std::getline(receiversStream, receiver, ',')) {
		receivers.push_back(receiver);
	}

	// Create a pair and return it
	std::pair<std::vector<std::string>, std::string> result;
	result.first = receivers;
	result.second = text;
	return result;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   TestJoin.cpp                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yde-goes <yde-goes@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/24 18:15:35 by yde-goes          #+#    #+#             */
/*   Updated: 2024/05/24 18:15:36 by yde-goes         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   TestNick.cpp                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yde-goes <yde-goes@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/24 18:03:34 by yde-goes          #+#    #+#             */
/*   Updated: 2024/05/25 21:21:28 by yde-goes         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <criterion/criterion.h>
#include <criterion/new/assert.h>
#include "Client.hpp"
#include "Channel.hpp"
#define private public
#include "Server.hpp"

Client *mockClient()
{
	Client *client = new Client();
	client->set_fd(4);
	client->set_username("username");
	client->set_nickname("oldNickname");
	client->set_password("password");
	client->set_buffer("NICK new_nickname");
	client->set_is_logged(true);
	client->set_is_authenticated(true);
	return client;
}

Test(NickCommand, err_erroneusnick_1)
{
	Client* client = mockClient();

	Server server;

	server._clients.push_back(*client);
	server._handler_client_nickname("new_nickname", 4);
	cr_assert(eq(int, server._reply_code, 432));
}

Test(NickCommand, err_erroneusnick_2)
{
	Client* client = mockClient();

	Server server;

	server._clients.push_back(*client);
	server._handler_client_nickname("new_n1c7n4m3", 4);
	cr_assert(eq(int, server._reply_code, 432));
}

Test(NickCommand, err_norregistered)
{
	Client* client = mockClient();
	client->set_is_authenticated(false);
	client->set_is_logged(false);

	Server server;

	server._clients.push_back(*client);
	server._handler_client_nickname("oldNickname", 4);
	cr_assert(eq(int, server._reply_code, 451));
}

Test(NickCommand, success_setnickname)
{
	Client* client = mockClient();

	Server server;

	server._clients.push_back(*client);
	server._handler_client_nickname("newNickname", 4);
	cr_assert(eq(int, server._reply_code, 200));
}

// THIS TEST IS NOT WORKING, returns 200 instead of 433. Don't know why :/
/* Test(NickCommand, err_nickinuse)
{
	Client* client = mockClient();

	Server server;

	server._clients.push_back(*client);
	server._handler_client_nickname(client->get_nickname(), 4);
	std::cout << server._get_client(4)->get_nickname() << std::endl;
	cr_assert(eq(int, server._reply_code, 433));
} */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   TestSplitMessage.cpp                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yde-goes <yde-goes@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/24 18:03:20 by yde-goes          #+#    #+#             */
/*   Updated: 2024/05/24 18:51:38 by yde-goes         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <criterion/criterion.h>
#include "Utils.hpp"
#include <vector>
#include <string>
#include <utility>

Test(split_message, should_split_message_into_receivers_and_text_1) {
	std::string message = "receiver1,receiver2,receiver3 This is a test message";

	std::pair<std::vector<std::string>, std::string> result = split_message(message);

	std::vector<std::string> expectedReceivers = {"receiver1", "receiver2", "receiver3"};
	std::string expectedText = "This is a test message";

	cr_assert_eq(result.first.size(), expectedReceivers.size(), "Number of receivers does not match");
	for (size_t i = 0; i < expectedReceivers.size(); i++) {
		cr_assert_str_eq(result.first[i].c_str(), expectedReceivers[i].c_str(), "Receiver %zu does not match", i);
	}

	cr_assert_str_eq(result.second.c_str(), expectedText.c_str(), "Text does not match");
}

Test(split_message, should_split_message_into_receivers_and_text_2) {
	std::string message = "receiver1,receiver2,receiver3, This is a test message";

	std::pair<std::vector<std::string>, std::string> result = split_message(message);

	std::vector<std::string> expectedReceivers = {"receiver1", "receiver2", "receiver3"};
	std::string expectedText = "This is a test message";

	cr_assert_eq(result.first.size(), expectedReceivers.size(), "Number of receivers does not match");
	for (size_t i = 0; i < expectedReceivers.size(); i++) {
		cr_assert_str_eq(result.first[i].c_str(), expectedReceivers[i].c_str(), "Receiver %zu does not match", i);
	}

	cr_assert_str_eq(result.second.c_str(), expectedText.c_str(), "Text does not match");
}


Test(split_message, should_split_message_into_receivers_and_text_3) {
	std::string message = "channel This is a test message";

	std::pair<std::vector<std::string>, std::string> result = split_message(message);

	std::vector<std::string> expectedReceivers = {"channel"};
	std::string expectedText = "This is a test message";

	cr_assert_eq(result.first.size(), expectedReceivers.size(), "Number of receivers does not match");
	for (size_t i = 0; i < expectedReceivers.size(); i++) {
		cr_assert_str_eq(result.first[i].c_str(), expectedReceivers[i].c_str(), "Receiver %zu does not match", i);
	}

	cr_assert_str_eq(result.second.c_str(), expectedText.c_str(), "Text does not match");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   TestUser.cpp                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yde-goes <yde-goes@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/24 18:03:11 by yde-goes          #+#    #+#             */
/*   Updated: 2024/05/25 21:19:12 by yde-goes         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <criterion/criterion.h>
#include <criterion/new/assert.h>
#include "Client.hpp"
#include "Channel.hpp"
#define private public
#include "Server.hpp"

Client *mockClient()
{
	Client *client = new Client();
	client->set_fd(4);
	client->set_username("username");
	client->set_nickname("oldNickname");
	client->set_password("password");
	client->set_buffer("USER new_username");
	client->set_is_logged(true);
	client->set_is_authenticated(true);
	return client;
}

Test(UserCommand, err_needmoreparams)
{
	Client* client = mockClient();

	Server server;

	server._clients.push_back(*client);
	server._handler_client_username("", 4);
	cr_assert(eq(int, server._reply_code, 461)); // Assuming 461 is the reply code for ERR_NEEDMOREPARAMS
}

Test(UserCommand, err_notregistered)
{
	Client* client = mockClient();
	client->set_is_authenticated(false);
	client->set_is_logged(false);

	Server server;

	server._clients.push_back(*client);
	server._handler_client_username("new_username", 4);
	cr_assert(eq(int, server._reply_code, 451)); // Assuming 451 is the reply code for ERR_NOTREGISTERED
}

Test(UserCommand, success_setusername_1)
{
	Client* client = mockClient();
	client->set_username("");

	Server server;

	server._clients.push_back(*client);
	server._handler_client_username("new_username", 4);
	cr_assert(eq(int, server._reply_code, 200)); // Assuming 200 is the reply code for a successful username change
}

// THIS TEST IS NOT WORKING. Maybe it should compare the strings?
/* Test(UserCommand, success_setusername_2)
{
	Client* client = mockClient();
	client->set_username("withUsername");

	Server server;

	server._clients.push_back(*client);
	server._handler_client_username("newUsername", 4);
	cr_assert(eq(int, server._reply_code, 200)); // Assuming 200 is the reply code for a successful username change
} */

Test(UserCommand, err_alreadyregistered)
{
	Client* client = mockClient();

	Server server;

	server._clients.push_back(*client);
	server._handler_client_username("username", 4);
	cr_assert(eq(int, server._reply_code, 462)); // Assuming 462 is the reply code for ERR_ALREADYREGISTERED
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   TestKick.cpp                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yde-goes <yde-goes@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/24 18:15:38 by yde-goes          #+#    #+#             */
/*   Updated: 2024/05/25 21:08:45 by yde-goes         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <criterion/criterion.h>
#include <criterion/new/assert.h>
#include "Client.hpp"
#include "Channel.hpp"
#define private public
#include "Server.hpp"

Client *mockOutsideClient()
{
	Client *client = new Client();
	client->set_fd(6);
	client->set_username("outsideUser");
	client->set_nickname("outsideUser");
	client->set_password("password");
	client->set_buffer("");
	client->set_is_logged(true);
	client->set_is_authenticated(true);
	return client;
}

Client *mockCommonClient()
{
	Client *client = new Client();
	client->set_fd(5);
	client->set_username("trollUser");
	client->set_nickname("trollUser");
	client->set_password("password");
	client->set_buffer("");
	client->set_is_logged(true);
	client->set_is_authenticated(true);
	return client;
}

Client *mockOperatorClient()
{
	Client *client = new Client();
	client->set_fd(4);
	client->set_username("channelOperator");
	client->set_nickname("channelOperator");
	client->set_password("password");
	client->set_buffer("");
	client->set_is_logged(true);
	client->set_is_authenticated(true);
	client->set_is_operator(false);
	return client;
}

Test(KickCommand, kick_successfully_no_comments)
{
	Client* troll = mockCommonClient();
	Client* channelOperator = mockOperatorClient();

	Server server;
	Channel *channel = new Channel("#world");

	// Add clients to the server clients list
	server._clients.push_back(*troll);
	server._clients.push_back(*channelOperator);

	// Add clients as channel member
	channel->invite(troll);
	channel->invite(channelOperator);

	// Set client channelOperator as channel operator
	// WARNING: for some reason, the channel must be added
	// to the server channels list AFTER setting the operator
	channelOperator->set_is_operator(true);
	channel->set_channel_operator(channelOperator);
	
	// Add channel to the server channels list
	server._channels.push_back(channel);

	// Kick troll from the channel
	server._handler_client_kick("#world trollUser", 4);
	cr_assert(eq(int, server._reply_code, 200));
	cr_assert(eq(int, server._get_channel(channel->get_name())->get_clients_size(), 1));
}

Test(KickCommand, kick_successfully_with_comments)
{
	Client* troll = mockCommonClient();
	Client* channelOperator = mockOperatorClient();

	Server server;
	Channel *channel = new Channel("#world");

	// Add clients to the server clients list
	server._clients.push_back(*troll);
	server._clients.push_back(*channelOperator);

	// Add clients as channel member
	channel->invite(troll);
	channel->invite(channelOperator);

	// Set client channelOperator as channel operator
	// WARNING: for some reason, the channel must be added
	// to the server channels list AFTER setting the operator
	channelOperator->set_is_operator(true);
	channel->set_channel_operator(channelOperator);
	
	// Add channel to the server channels list
	server._channels.push_back(channel);

	// Print get_operator_clients
	/*std::vector<Client *> operator_clients = channel->get_operator_clients();

	for (std::vector<Client *>::const_iterator it = operator_clients.begin(); it != operator_clients.end(); ++it)
	{
		std::cout << (*it)->get_nickname() << std::endl;
		std::cout << (*it)->get_fd() << std::endl;
		std::cout << (*it)->get_is_operator() << std::endl;
	} */

	// Kick troll from the channel
	server._handler_client_kick("#world trollUser trolou", 4);
	cr_assert(eq(int, server._reply_code, 200));
	cr_assert(eq(int, server._get_channel(channel->get_name())->get_clients_size(), 1));
}

/* Test(KickCommand, err_needmoreparams)
{
	Client* troll = mockCommonClient();
	Client* channelOperator = mockOperatorClient();

	Server server;
	Channel *channel = new Channel("#world");

	// Add clients to the server clients list
	server._clients.push_back(*troll);
	server._clients.push_back(*channelOperator);

	// Add clients as channel member
	channel->invite(troll);
	channel->invite(channelOperator);

	// Set client channelOperator as channel operator	
	channel->set_channel_operator(channelOperator);
	
	// Add channel to the server channels list
	server._channels.push_back(channel);

	// Kick troll from the channel
	server._handler_client_kick("", 4);
	cr_assert(eq(int, server._reply_code, 461));
} */

Test(KickCommand, err_nosuchchannel)
{
	Client* troll = mockCommonClient();
	Client* channelOperator = mockOperatorClient();

	Server server;
	Channel *channel = new Channel("#world");

	// Add clients to the server clients list
	server._clients.push_back(*troll);
	server._clients.push_back(*channelOperator);

	// Add clients as channel member
	channel->invite(troll);
	channel->invite(channelOperator);

	// Set client channelOperator as channel operator	
	channel->set_channel_operator(channelOperator);
	
	// Add channel to the server channels list
	server._channels.push_back(channel);

	// Kick troll from the channel
	server._handler_client_kick("#deadworld trollUser", 4);
	cr_assert(eq(int, server._reply_code, 403));
}

Test(KickCommand, err_notonchannel)
{
	Client* troll = mockCommonClient();
	Client* channelOperator = mockOperatorClient();
	Client* outsideUser = mockOutsideClient();

	Server server;
	Channel *channel = new Channel("#world");

	// Add clients to the server clients list
	server._clients.push_back(*troll);
	server._clients.push_back(*channelOperator);
	server._clients.push_back(*outsideUser);

	// Add clients as channel member
	channel->invite(troll);
	channel->invite(channelOperator);

	// Set client channelOperator as channel operator	
	channel->set_channel_operator(channelOperator);
	
	// Add channel to the server channels list
	server._channels.push_back(channel);

	// Kick troll from the channel
	server._handler_client_kick("#world trollUser", 6);
	cr_assert(eq(int, server._reply_code, 442));
}

Test(KickCommand, err_chanoprivsneeded)
{
	Client* troll = mockCommonClient();
	Client* channelOperator = mockOperatorClient();

	Server server;
	Channel *channel = new Channel("#world");

	channelOperator->set_is_operator(false);

	// Add clients to the server clients list
	server._clients.push_back(*troll);
	server._clients.push_back(*channelOperator);

	// Add clients as channel member
	channel->invite(troll);
	channel->invite(channelOperator);
	
	// Add channel to the server channels list
	server._channels.push_back(channel);

	// Kick troll from the channel
	server._handler_client_kick("#world trollUser", 4);
	cr_assert(eq(int, server._reply_code, 482));
}

Test(KickCommand, err_nosuchnick)
{
	Client* troll = mockCommonClient();
	Client* channelOperator = mockOperatorClient();

	Server server;
	Channel *channel = new Channel("#world");

	channelOperator->set_is_operator(false);

	// Add clients to the server clients list
	server._clients.push_back(*troll);
	server._clients.push_back(*channelOperator);

	// Add clients as channel member
	channel->invite(troll);
	channel->invite(channelOperator);

	// Set client channelOperator as channel operator
	// WARNING: for some reason, the channel must be added
	// to the server channels list AFTER setting the operator
	channelOperator->set_is_operator(true);
	channel->set_channel_operator(channelOperator);
	
	// Add channel to the server channels list
	server._channels.push_back(channel);

	// Kick troll from the channel
	server._handler_client_kick("#world noUserInServer", 4);
	cr_assert(eq(int, server._reply_code, 401));
}

Test(KickCommand, err_usernotinchannel)
{
	Client* troll = mockCommonClient();
	Client* channelOperator = mockOperatorClient();
	Client* outsideUser = mockOutsideClient();

	Server server;
	Channel *channel = new Channel("#world");

	channelOperator->set_is_operator(false);

	// Add clients to the server clients list
	server._clients.push_back(*troll);
	server._clients.push_back(*channelOperator);
	server._clients.push_back(*outsideUser);

	// Add clients as channel member
	channel->invite(troll);
	channel->invite(channelOperator);

	// Set client channelOperator as channel operator
	// WARNING: for some reason, the channel must be added
	// to the server channels list AFTER setting the operator
	channelOperator->set_is_operator(true);
	channel->set_channel_operator(channelOperator);
	
	// Add channel to the server channels list
	server._channels.push_back(channel);

	// Kick troll from the channel
	server._handler_client_kick("#world outsideUser", 4);
	cr_assert(eq(int, server._reply_code, 441));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Utils.hpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yde-goes <yde-goes@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/24 18:03:01 by yde-goes          #+#    #+#             */
/*   Updated: 2024/05/24 18:51:12 by yde-goes         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef UTILS_HPP
# define UTILS_HPP

# define EPSILON 0.0001

#include <vector>
#include <string>
#include <sstream>

std::pair<std::vector<std::string>, std::string> split_message(
	const std::string& message);

# endif // UTILS_HPP/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   TestInvite.cpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yde-goes <yde-goes@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/24 18:15:32 by yde-goes          #+#    #+#             */
/*   Updated: 2024/05/25 21:14:16 by yde-goes         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <criterion/criterion.h>
#include <criterion/new/assert.h>
#include "Client.hpp"
#include "Channel.hpp"
#define private public
#include "Server.hpp"

Client *mockOutsideClient()
{
	Client *client = new Client();
	client->set_fd(5);
	client->set_username("outsideUser");
	client->set_nickname("outsideUser");
	client->set_password("password");
	client->set_buffer("");
	client->set_is_logged(true);
	client->set_is_authenticated(true);
	return client;
}

Client *mockInsideClient()
{
	Client *client = new Client();
	client->set_fd(4);
	client->set_username("insideUser");
	client->set_nickname("insideUser");
	client->set_password("password");
	client->set_buffer("");
	client->set_is_logged(true);
	client->set_is_authenticated(true);
	client->set_is_operator(false);
	return client;
}

Test(InviteCommand, succesfully_invite_client_to_channel)
{
	Client* outsideClient = mockOutsideClient();
	Client* insideClient = mockInsideClient();

	Server server;
	Channel *channel = new Channel("#world");

	channel->set_channel_operator(insideClient);

	// Add clients to the server clients list
    server._clients.push_back(*outsideClient);
	server._clients.push_back(*insideClient);

	// Add clients as channel member
	channel->invite(insideClient);

	// Add channel to the server channels list
    server._channels.push_back(channel);

	// Invite client to channel
	server._handler_client_invite("outsideUser #world", 4);
	cr_assert(eq(int, server._reply_code, 200));
	cr_assert(eq(int, server._get_channel(channel->get_name())->get_clients_size(), 2));
}

Test(InviteCommand, err_nosuchchannel)
{
	Client* outsideClient = mockOutsideClient();
	Client* insideClient = mockInsideClient();

	Server server;
	Channel *channel = new Channel("#world");

	// Add clients to the server clients list
    server._clients.push_back(*outsideClient);
	server._clients.push_back(*insideClient);
	
	// Add channel to the server channels list
    server._channels.push_back(channel);

	// Invite client to channel
	server._handler_client_invite("outsideClient #deadworld", 4);
	cr_assert(eq(int, server._reply_code, 403));
}

Test(InviteCommand, err_notonchannel)
{
	Client* outsideClient = mockOutsideClient();
	Client* insideClient = mockInsideClient();

	Server server;
	Channel *channel = new Channel("#world");

	// Add clients to the server clients list
    server._clients.push_back(*outsideClient);
	server._clients.push_back(*insideClient);

	channel->invite(outsideClient);
	
	// Add channel to the server channels list
    server._channels.push_back(channel);

	// Invite client to channel
	server._handler_client_invite("outsideClient #world", 4);
	cr_assert(eq(int, server._reply_code, 442));
}

Test(InviteCommand, err_nosuchnick)
{
	Client* insideClient = mockInsideClient();

	Server server;
	Channel *channel = new Channel("#world");

	channel->set_channel_operator(insideClient);

	// Add clients to the server clients list
	server._clients.push_back(*insideClient);

	channel->invite(insideClient);
	
	// Add channel to the server channels list
    server._channels.push_back(channel);

	// Invite client to channel
	server._handler_client_invite("outsideClient #world", 4);
	cr_assert(eq(int, server._reply_code, 401));
}

Test(InviteCommand, err_noprivileges)
{
	Client* insideClient = mockInsideClient();

	Server server;
	Channel *channel = new Channel("#world");

	// Add clients to the server clients list
	server._clients.push_back(*insideClient);

	// Add clients as channel member
	channel->invite(insideClient);

	// Add channel to the server channels list
    server._channels.push_back(channel);

	// Invite client to channel
	server._handler_client_invite("outsideUser #world", 4);
	cr_assert(eq(int, server._reply_code, 481));
}
	
Test(InviteCommand, err_useronchannel)
{
	Client* insideClient = mockInsideClient();

	Server server;
	Channel *channel = new Channel("#world");

	channel->set_channel_operator(insideClient);

	// Add clients to the server clients list
	server._clients.push_back(*insideClient);

	channel->invite(insideClient);
	
	// Add channel to the server channels list
    server._channels.push_back(channel);

	// Invite client to channel
	server._handler_client_invite("insideUser #world", 4);
	cr_assert(eq(int, server._reply_code, 443));
}

Test(InviteCommand, err_notregistered)
{
	Client* insideClient = mockInsideClient();

	Server server;
	Channel *channel = new Channel("#world");

	insideClient->set_is_logged(false);

	// Add clients to the server clients list
	server._clients.push_back(*insideClient);

	channel->invite(insideClient);
	
	// Add channel to the server channels list
    server._channels.push_back(channel);

	// Invite client to channel
	server._handler_client_invite("insideUser #world", 4);
	cr_assert(eq(int, server._reply_code, 451));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   TestPart.cpp                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yde-goes <yde-goes@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/25 08:56:56 by yde-goes          #+#    #+#             */
/*   Updated: 2024/05/25 21:14:47 by yde-goes         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <criterion/criterion.h>
#include <criterion/new/assert.h>
#include "Client.hpp"
#include "Channel.hpp"
#define private public
#include "Server.hpp"

Client *genericClient()
{
	Client *client = new Client();
	client->set_fd(6);
	client->set_username("soAndSoUser");
	client->set_nickname("soAndSoUser");
	client->set_password("password");
	client->set_buffer("");
	client->set_is_logged(true);
	client->set_is_authenticated(true);
	return client;
}

Client *toPartClient()
{
	Client *client = new Client();
	client->set_fd(4);
	client->set_username("toPartUser");
	client->set_nickname("toPartUser");
	client->set_password("password");
	client->set_buffer("");
	client->set_is_logged(true);
	client->set_is_authenticated(true);
	client->set_is_operator(false);
	return client;
}

Test(PartCommand, part_successfully)
{
	Client *toPart = toPartClient();
	Client *channelMember = genericClient();

	Server server;

	Channel *channel = new Channel("#channel");

	server._clients.push_back(*toPart);
	server._clients.push_back(*channelMember);

	std::cout << channel->get_clients_size() << std::endl;

	channel->invite(toPart);
	channel->invite(channelMember);

	server._channels.push_back(channel);

	server._handler_client_part("#channel", toPart->get_fd());

	cr_assert(eq(int, server._reply_code, 200));
	cr_assert(eq(int, server._get_channel(channel->get_name())->get_clients_size(), 1));
}


Test(PartCommand, err_nosuchchannel)
{
	Client *toPart = toPartClient();
	Client *channelMember = genericClient();

	Server server;

	Channel *channel = new Channel("#channel");

	server._clients.push_back(*toPart);
	server._clients.push_back(*channelMember);

	std::cout << channel->get_clients_size() << std::endl;

	channel->invite(toPart);
	channel->invite(channelMember);

	server._channels.push_back(channel);

	server._handler_client_part("#nonExistent", toPart->get_fd());

	cr_assert(eq(int, server._reply_code, 403));
}

Test(PartCommand, err_notonchannel)
{
	Client *toPart = toPartClient();
	Client *channelMember = genericClient();

	Server server;

	Channel *channel = new Channel("#channel");

	server._clients.push_back(*toPart);
	server._clients.push_back(*channelMember);

	std::cout << channel->get_clients_size() << std::endl;

	channel->invite(channelMember);

	server._channels.push_back(channel);

	server._handler_client_part("#channel", toPart->get_fd());

	cr_assert(eq(int, server._reply_code, 442));
}

Test(PartCommand, err_notregistered)
{
	Client *toPart = toPartClient();
	Client *channelMember = genericClient();

	Server server;

	Channel *channel = new Channel("#channel");

	toPart->set_is_logged(false);

	server._clients.push_back(*toPart);
	server._clients.push_back(*channelMember);

	std::cout << channel->get_clients_size() << std::endl;

	channel->invite(channelMember);
	channel->invite(toPart);

	server._channels.push_back(channel);

	server._handler_client_part("#channel", toPart->get_fd());

	cr_assert(eq(int, server._reply_code, 451));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   TestTopic.cpp                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yde-goes <yde-goes@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/25 08:57:00 by yde-goes          #+#    #+#             */
/*   Updated: 2024/05/25 08:57:01 by yde-goes         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   TestPrivmsg.cpp                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yde-goes <yde-goes@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/25 09:03:10 by yde-goes          #+#    #+#             */
/*   Updated: 2024/05/25 21:15:42 by yde-goes         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <criterion/criterion.h>
#include <criterion/new/assert.h>
#include "Client.hpp"
#include "Channel.hpp"
#define private public
#include "Server.hpp"

Client *secondReceiver()
{
	Client *client = new Client();
	client->set_fd(6);
	client->set_username("secondUser");
	client->set_nickname("secondUser");
	client->set_password("password");
	client->set_buffer("");
	client->set_is_logged(true);
	client->set_is_authenticated(true);
	return client;
}

Client *firstReceiver()
{
	Client *client = new Client();
	client->set_fd(5);
	client->set_username("firstUser");
	client->set_nickname("firstUser");
	client->set_password("password");
	client->set_buffer("");
	client->set_is_logged(true);
	client->set_is_authenticated(true);
	return client;
}

Client *senderClient()
{
	Client *client = new Client();
	client->set_fd(4);
	client->set_username("senderUser");
	client->set_nickname("senderUser");
	client->set_password("password");
	client->set_buffer("");
	client->set_is_logged(true);
	client->set_is_authenticated(true);
	client->set_is_operator(false);
	return client;
}

/* Test(PrivmsgCommand, privmsg_successfully_single_client)
{
	Client *sender = senderClient();
	Client *first = firstReceiver();
	Client *second = secondReceiver();

	Server server;

	server._clients.push_back(*sender);
	server._clients.push_back(*first);
	server._clients.push_back(*second);

	server._handler_client_privmsg("firstUser :Hello, firstUser!", 4);
	cr_assert(eq(int, server._reply_code, 0));
}

Test(PrivmsgCommand, privmsg_successfully_two_clients)
{
	Client *sender = senderClient();
	Client *first = firstReceiver();
	Client *second = secondReceiver();

	Server server;

	server._clients.push_back(*sender);
	server._clients.push_back(*first);
	server._clients.push_back(*second);

	server._handler_client_privmsg("firstUser,secondUser :Hello, my Users!", 4);
	cr_assert(eq(int, server._reply_code, 0));
}

Test(PrivmsgCommand, privmsg_successfully_single_channel)
{
	Client *sender = senderClient();
	Client *first = firstReceiver();
	Client *second = secondReceiver();

	Server server;

	server._clients.push_back(*sender);
	server._clients.push_back(*first);
	server._clients.push_back(*second);

	Channel *channel = new Channel("#brazil");
	
	channel->invite(sender);
	server._channels.push_back(channel);

	server._handler_client_privmsg("#brazil :Hello, BRAZIL!", 4);
	cr_assert(eq(int, server._reply_code, 0));
} */

Test(PrivmsgCommand, privmsg_successfully_three_channels)
{
	Client *sender = senderClient();
	Client *first = firstReceiver();
	Client *second = secondReceiver();

	Server server;

	server._clients.push_back(*sender);
	server._clients.push_back(*first);
	server._clients.push_back(*second);

	Channel *ch_brazil = new Channel("#brazil");
	Channel *ch_france = new Channel("#france");
	Channel *ch_spain = new Channel("#spain");
	
	ch_brazil->invite(sender);
	ch_france->invite(sender);
	ch_france->invite(first);
	ch_france->invite(second);
	ch_spain->invite(sender);
	ch_spain->invite(first);
	server._channels.push_back(ch_brazil);
	server._channels.push_back(ch_france);
	server._channels.push_back(ch_spain);

	server._handler_client_privmsg("#brazil,#france,#spain :Hello, WORLD!", 4);
	cr_assert(eq(int, server._reply_code, 0));
}

/* Test(PrivmsgCommand, privmsg_successfully_mixed_channel_user)
{
	Client *sender = senderClient();
	Client *first = firstReceiver();
	Client *second = secondReceiver();

	Server server;

	server._clients.push_back(*sender);
	server._clients.push_back(*first);
	server._clients.push_back(*second);

	Channel *ch_brazil = new Channel("#brazil");
	Channel *ch_france = new Channel("#france");
	Channel *ch_spain = new Channel("#spain");
	
	ch_brazil->invite(sender);
	ch_france->invite(sender);
	ch_spain->invite(sender);
	server._channels.push_back(ch_brazil);
	server._channels.push_back(ch_france);
	server._channels.push_back(ch_spain);

	server._handler_client_privmsg("#brazil,firstUser,#france,secondUser,#spain :Hello, WORLD!", 4);
	cr_assert(eq(int, server._reply_code, 0));
}

Test(PrivmsgCommand, err_notregistered)
{
	Client *sender = senderClient();
	Client *first = firstReceiver();
	Client *second = secondReceiver();

	Server server;

	sender->set_is_logged(false);

	server._clients.push_back(*sender);
	server._clients.push_back(*first);
	server._clients.push_back(*second);

	server._handler_client_privmsg("firstUser :Hello, firstUser!", 4);
	cr_assert(eq(int, server._reply_code, 451));
}

Test(PrivmsgCommand, err_nosuchchannel)
{
	Client *sender = senderClient();
	Client *first = firstReceiver();
	Client *second = secondReceiver();

	Server server;

	server._clients.push_back(*sender);
	server._clients.push_back(*first);
	server._clients.push_back(*second);

	Channel *ch_brazil = new Channel("#brazil");
	Channel *ch_france = new Channel("#france");
	Channel *ch_spain = new Channel("#spain");
	
	ch_brazil->invite(sender);
	ch_france->invite(sender);
	ch_spain->invite(sender);
	server._channels.push_back(ch_brazil);
	server._channels.push_back(ch_france);
	server._channels.push_back(ch_spain);

	server._handler_client_privmsg("#brazil,firstUser,#neptune,secondUser,#spain :Hello, WORLD!", 4);
	cr_assert(eq(int, server._reply_code, 403));
}

Test(PrivmsgCommand, err_notonchannel)
{
	Client *sender = senderClient();
	Client *first = firstReceiver();
	Client *second = secondReceiver();

	Server server;

	server._clients.push_back(*sender);
	server._clients.push_back(*first);
	server._clients.push_back(*second);

	Channel *ch_brazil = new Channel("#brazil");
	Channel *ch_france = new Channel("#france");
	Channel *ch_spain = new Channel("#spain");
	
	ch_brazil->invite(sender);
	ch_spain->invite(sender);
	server._channels.push_back(ch_brazil);
	server._channels.push_back(ch_france);
	server._channels.push_back(ch_spain);

	server._handler_client_privmsg("#brazil,firstUser,#france,secondUser,#spain :Hello, WORLD!", 4);
	cr_assert(eq(int, server._reply_code, 442));
}

Test(PrivmsgCommand, err_nosuchnick)
{
	Client *sender = senderClient();
	Client *first = firstReceiver();
	Client *second = secondReceiver();

	Server server;

	server._clients.push_back(*sender);
	server._clients.push_back(*first);
	server._clients.push_back(*second);

	Channel *ch_brazil = new Channel("#brazil");
	Channel *ch_france = new Channel("#france");
	Channel *ch_spain = new Channel("#spain");
	
	ch_brazil->invite(sender);
	ch_france->invite(sender);
	ch_spain->invite(sender);
	server._channels.push_back(ch_brazil);
	server._channels.push_back(ch_france);
	server._channels.push_back(ch_spain);

	server._handler_client_privmsg("#brazil,thirdUser,#france,secondUser,#spain :Hello, WORLD!", 4);
	cr_assert(eq(int, server._reply_code, 401));
}
 *//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Client.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/28 10:20:02 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 19:10:24 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Client.hpp"

/*
** ------------------------------- CONSTRUCTOR --------------------------------
*/

Client::Client()
{
	_fd = -1;
	_ip_addr = "";
	_nickname = "";
	_username = "";
	_password = "";
	_buffer = "";
	_is_logged = false;
	_is_authenticated = false;
	_is_operator = false;
}

/*
** --------------------------------- ACCESSOR ---------------------------------
*/

void Client::set_fd(const int fd)
{
	_fd = fd;
}

void Client::set_ip_add(const std::string &ipadd)
{
	_ip_addr = ipadd;
}

void Client::set_buffer(const std::string &buffer)
{
	_buffer = buffer;
}

void Client::set_nickname(const std::string &nickname)
{
	_nickname = nickname;
}

void Client::set_username(const std::string &username)
{
	_username = username;
}

void Client::set_password(const std::string &password)
{
	_password = password;
}

void Client::set_is_authenticated(bool is_authenticated)
{
	_is_authenticated = is_authenticated;
}

void Client::set_is_operator(bool is_operator)
{
	_is_operator = is_operator;
}

void Client::set_is_logged(bool is_logged)
{
	_is_logged = is_logged;
}

bool Client::get_is_authenticated() const
{
	return _is_authenticated;
}

bool Client::get_is_operator() const
{
	return _is_operator;
}

bool Client::get_is_logged() const
{
	return _is_logged;
}

int Client::get_fd() const
{
	return _fd;
}

std::string Client::get_buffer() const
{
	return _buffer;
}

std::string Client::get_nickname() const
{
	return _nickname;
}

std::string Client::get_username() const
{
	return _username;
}

std::string Client::get_password() const
{
	return _password;
}

std::string Client::get_hostname() const
{
	return _nickname + "@" + _ip_addr;
}

void Client::add_channel_invited(const std::string &channel)
{
	_channels_invited.push_back(channel);
}

bool Client::is_channel_invited(const std::string &channel)
{
	return std::find(_channels_invited.begin(), _channels_invited.end(), channel) != _channels_invited.end();
}

void Client::broadcast(Client *sender, std::string command, std::string target, std::string message)
{
	(void)command;
	std::string response = RPL_PRIVMSG(sender->get_hostname(), target, message);

	if (send(sender->get_fd(), response.c_str(), response.size(), 0) == -1)
		std::cerr << "Response send() failed" << std::endl;

  //_send_response(fd, RPL_PRIVMSG(client->get_hostname(),
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Channel.cpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:26:17 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 23:09:04 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Channel.hpp"

/*
** ------------------------------- CONSTRUCTOR --------------------------------
*/

Channel::Channel()
{
	_key = "";
	_name = "";
	_topic = "";
	_limit = -1;
	_created_at = "";
	_has_key = false;
}

Channel::Channel(std::string name)
{
	_key = "";
	_topic = "";
	_limit = -1;
	_name = name;
	_created_at = "";
	_has_key = false;
}

/*
** -------------------------------- DESTRUCTOR --------------------------------
*/

Channel::~Channel()
{
	this->_clients.clear();
	this->_operator_clients.clear();
	return ;
}

/*
** --------------------------------- ACCESSOR ---------------------------------
*/

std::string Channel::get_name(void) const
{
	return _name;
}

std::vector<Client *> Channel::get_operator_clients(void)
{
	return this->_operator_clients;
}

std::vector<Client *> Channel::get_channel_clients(void)
{
	return this->_clients;
}

std::string Channel::get_client_names(void) const
{
	std::string names;
	for (std::vector<Client *>::const_iterator it = this->_clients.begin(); it != this->_clients.end(); ++it)
	{
		names += (*it)->get_nickname();
		names += " ";
	}
	return names;
}

int Channel::get_clients_size(void) const
{
	return this->_clients.size();
}

std::string Channel::get_topic(void) const
{
	return _topic;
}

std::string Channel::get_channel_key(void) const
{
	return _key;
}

void Channel::set_channel_operator(Client *client)
{
	client->set_is_operator(true);
	this->_operator_clients.push_back(client);
	return ;
}

void Channel::set_topic(std::string topic)
{
	_topic = topic;
}

void Channel::set_limit(int limit)
{
	_limit = limit;
}

void Channel::set_invite_only()
{
	_invite_only = true;
}

void Channel::set_topic_restriction()
{
	_topic_restriction = true;
}

void Channel::set_key(std::string key)
{
	_key = key;
}

void Channel::remove_limit(void)
{
	_limit = -1;
}

void Channel::remove_key(void)
{
	_key = "";
}

void Channel::remove_topic_restriction(void)
{
	_topic_restriction = false;
}

void Channel::remove_invite_only(void)
{
	_invite_only = false;
}

void Channel::remove_channel_operator(Client *client)
{
	client->set_is_operator(false);
	for (std::vector<Client *>::iterator it = this->_operator_clients.begin(); it != this->_operator_clients.end(); ++it)
	{
		if((*it)->get_nickname() == client->get_nickname())
		{
			this->_operator_clients.erase(it);
			return ;
		}
	}
}

/*
** --------------------------------- OTHERS ---------------------------------
*/

// Channel STATUS and checker functions
bool Channel::has_client(Client *client)
{
	for (std::vector<Client *>::const_iterator it = this->_clients.begin(); it != this->_clients.end(); ++it)
	{
		if ((*it)->get_nickname() == client->get_nickname())
			return true;
	}
	return false;
}

bool Channel::has_key(void) const
{
	return _key != "";
}

bool Channel::is_channel_operator(std::string nickname)
{
	for (std::vector<Client *>::iterator it = _operator_clients.begin(); it != this->_operator_clients.end(); ++it)
	{
		if ((*it)->get_nickname() == nickname)
			return true;
	}
	return false;
}

// Member functions for CHANNEL MANAGEMENT
void Channel::invite(Client *client)
{
	_clients.push_back(client);
	return ;
}

void Channel::join(Client *client)
{
	_clients.push_back(client);
	return ;
}

void Channel::kick(Client *client)
{
	for (std::vector<Client *>::iterator it = this->_clients.begin(); it != this->_clients.end(); ++it)
	{
		if((*it)->get_nickname() == client->get_nickname())
		{
			this->_clients.erase(it);
			return ;
		}
	}
	return ;
}

void Channel::part(Client *client)
{
	// Remove client from channel operators
	for (std::vector<Client *>::iterator it_op = this->_operator_clients.begin(); it_op != this->_operator_clients.end(); ++it_op)
	{
		if((*it_op)->get_nickname() == client->get_nickname())
		{
			this->_operator_clients.erase(it_op);
			return ;
		}
	}

	for (std::vector<Client *>::iterator it = this->_clients.begin(); it != this->_clients.end(); ++it)
	{
		if((*it)->get_nickname() == client->get_nickname())
		{
			std::cout << (*it)->get_nickname() << std::endl;
			this->_clients.erase(it);
			return ;
		}
	}
}

void Channel::broadcast(Client *sender, std::string command, std::string target, std::string message)
{
	for (std::vector<Client *>::iterator it = this->_clients.begin(); it != this->_clients.end(); it++) {
		if (*it == sender)
			continue ;
		std::cout << "2) " << this->get_name() << " : " << (*it)->get_nickname() << std::endl;
		(*it)->broadcast(sender, command, target, message);
	}
	return ;
}

bool Channel::is_client_in_channel(std::string nickname)
{
	for (std::vector<Client *>::iterator it = this->_clients.begin(); it != this->_clients.end(); ++it)
	{
		if((*it)->get_nickname() == nickname)
			return true;
	}
	return false;
}

bool Channel::is_channel_full(void) const
{
	if (_limit == -1)
		return false;
	if (_clients.size() >= static_cast<size_t>(_limit))
		return true;
	return false;
}

bool Channel::is_channel_invite_only(void) const
{
	return _invite_only;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Kick.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:30:47 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 20:29:27 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"

/*
 * Command: Kick 
 * Parameters: <channel> <user> [<comment>]
 * Reference: https://datatracker.ietf.org/doc/html/rfc1459#section-4.2.8
*/

/**
 * @brief Handles the KICK command received from the client.
 *
 * This method processes the KICK command received from the client and sends a response
 * to the client indicating that the client has been kicked from the channel.
 *
 * @param buffer The buffer containing the KICK command parameters.
 * @param fd The file descriptor associated with the client that sent the command.
 */
void Server::_handler_client_kick(const std::string &buffer, const int fd)
{
	Client* client = _get_client(fd);

	/*
	std::cout << client->get_nickname() << " is trying to kick a user" << std::endl;
	std::cout << client->get_fd() << std::endl;
	std::cout << client->get_password() << std::endl;
	std::cout << client->get_is_authenticated() << std::endl;
	std::cout << client->get_is_registered() << std::endl;
	std::cout << client->get_is_operator() << std::endl;
	*/

	if (!client->get_is_logged()) {
        _send_response(fd, ERR_NOTREGISTERED(client->get_nickname()));
        _reply_code = 451;
        return;
    }

    // Divide o buffer em parâmetros e verifica se há parâmetros suficientes
    std::vector<std::string> params = _split_buffer(buffer, SPACE);
    if (params.size() < 2) {
        _send_response(fd, ERR_NEEDMOREPARAMS(client->get_nickname()));
        _reply_code = 461;
        return;
    }

    // Extrai o nome do canal e o apelido do cliente a ser expulso
    std::string channel_name = params[0];
    std::vector<std::string> comments = _split_buffer(params[1], SPACE);
    std::string target_nickname = comments[0];

    // Verifica se o canal existe
    Channel *channel = _get_channel(channel_name);
    if (!channel) {
        _send_response(fd, ERR_NOSUCHCHANNEL(channel_name));
        _reply_code = 403;
        return;
    }

    // Verifica se o cliente está no canal
    if (!channel->has_client(client)) {
        _send_response(fd, ERR_NOTONCHANNEL(channel_name));
        _reply_code = 442;
        return;
    }

    // Verifica se o cliente é um operador do canal
    if (!channel->is_channel_operator(client->get_nickname())) {
        _send_response(fd, ERR_CHANOPRIVSNEEDED(channel_name));
        _reply_code = 482;
        return;
    }

    // Verifica se o cliente alvo existe
    Client *target_client = _get_client(target_nickname);
    if (!target_client) {
        _send_response(fd, ERR_NOSUCHNICK(channel_name, target_nickname));
        _reply_code = 401;
        return;
    }

    // Verifica se o cliente alvo está no canal
    if (!channel->has_client(target_client)) {
        _send_response(fd, ERR_USERNOTINCHANNEL(target_nickname, channel_name));
        _reply_code = 441;
        return;
    }

	// Check if option parameter <comment> exists
	if (params.size() > 2) {
		_send_response(fd, RPL_KICK(client->get_hostname(), channel_name, client->get_nickname(), target_client->get_nickname(), comments[1]));
	} else {
		_send_response(fd, RPL_KICK(client->get_hostname(), channel_name, client->get_nickname(), target_client->get_nickname(), ""));
	}
    
	channel->kick(target_client);
	_reply_code = 200;

    // Registra o comando KICK recebido
    std::cout << "KICK command received from client " << buffer << std::endl;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Topic.cpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:30:59 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 22:46:34 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"

#define TOPIC_CMD "TOPIC"

/*
 * Command: TOPIC
 * Parameters: <channel> [<topic>]
 * Reference: https://datatracker.ietf.org/doc/html/rfc1459#section-4.2.4
*/

/**
 * @brief Handles the TOPIC command received from the client.
 *
 * This method processes the TOPIC command received from the client and sends a response
 * to the client indicating the topic of the channel.
 *
 * @param buffer The buffer containing the TOPIC command parameters.
 * @param fd The file descriptor associated with the client that sent the command.
 */
void Server::_handler_client_topic(const std::string &buffer, const int fd)
{
	// Registra o comando TOPIC recebido
    std::cout << "TOPIC command received: " << buffer << std::endl;
	
	std::istringstream iss(buffer);
	std::string chnl, topic;
	iss >> chnl >> topic;

	Client* client = _get_client(fd);
	Channel* channel = _get_channel(chnl);

	if (!client->get_is_logged()) {
		_send_response(fd, ERR_NOTREGISTERED(client->get_nickname()));
		_reply_code = 451;
	} else if (!channel) {
        _send_response(fd, ERR_NOSUCHCHANNEL(chnl));
		_reply_code = 403;
    } else if (!channel->is_client_in_channel(client->get_nickname())) {
        _send_response(fd, ERR_NOTONCHANNEL(client->get_nickname()));
		_reply_code = 442;
    } else if (topic.empty()) {
		if (channel->get_topic().empty()) {
        	_send_response(fd, RPL_NOTOPIC(client->get_nickname(), channel->get_name()));
			_reply_code = 331;
		} else {
			_send_response(fd, RPL_TOPIC(client->get_nickname(), channel->get_name(), channel->get_topic()));
			_reply_code = 332;
		}
    } else {
		if (!channel->is_channel_operator(client->get_nickname())) {
			_send_response(fd, ERR_NOTOPERATOR(channel->get_name()));
			_reply_code = 482;
        } else {
			channel->set_topic(topic);
        	_send_response(fd, RPL_TOPIC(client->get_nickname(), chnl, topic));
			_reply_code = 332;
		}
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Pass.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:32:39 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 19:48:54 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"

/*
 * Command: PASS
 * Parameters: <password>
 * Reference: https://datatracker.ietf.org/doc/html/rfc1459#section-4.1.1
*/

/**
 * @brief Handles the PASSWORD command received from the client.
 *
 * This method processes the PASSWORD command received from the client and sends a response
 * to the client indicating that the client's password has been set.
 *
 * @param password The password to be assigned to the client.
 * @param fd The file descriptor associated with the client that sent the command.
 */
void Server::_handler_client_password(const std::string &buffer, const int fd)
{
	// Registra o comando PASS recebido
    std::cout << "PASS command received: " << buffer << std::endl;
	
	Client* client = _get_client(fd);
	
	if (buffer.empty()) {
		_send_response(fd, ERR_NEEDMOREPARAMS(std::string("*")));
		_reply_code = 461;
	} else if (client->get_is_authenticated()) {
		_send_response(fd, ERR_ALREADYREGISTERED(std::string("*")));
		_reply_code = 462;
	} else if (_password != buffer) {
		_send_response(fd, ERR_INCORPASS(std::string("*")));
		_reply_code = 464;
	} else {
		client->set_is_authenticated(true);
		_reply_code = 200;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Part.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:30:20 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 11:52:13 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"

/*
 * Command: PART
 * Parameters: <channel>{,<channel>}
 * Link: https://datatracker.ietf.org/doc/html/rfc1459#section-4.2.2
*/

/**
 * @brief Handles the PART command received from the client.
 *
 * This method processes the PART command received from the client and sends a response
 * to the client indicating that the client has left the channel.
 *
 * @param buffer The buffer containing the PART command parameters.
 * @param fd The file descriptor associated with the client that sent the command.
 */
void Server::_handler_client_part(const std::string &buffer, const int fd)
{
    // Obtém o cliente associado ao descritor de arquivo (fd)
    Client* client = _get_client(fd);

    // Verifica se o cliente está registrado e autenticado
    if (!client->get_is_logged()) {
        _send_response(fd, ERR_NOTREGISTERED(client->get_nickname()));
        _reply_code = 451;
        return;
    }

    // Divide o buffer em parâmetros
    std::vector<std::string> params = _split_buffer(buffer, SPACE);
    if (params.size() < 1) {
        _send_response(fd, ERR_NEEDMOREPARAMS(client->get_nickname()));
        _reply_code = 461;
        return;
    }

    // Extrai o nome do canal a ser deixado
    std::string channel_name = params[0];

    Channel *channel = _get_channel(channel_name);
    if (!channel) {
        _send_response(fd, ERR_NOSUCHCHANNEL(channel_name));
        _reply_code = 403;
        return;
    }

    // Verifica se o cliente está no canal
    if (!channel->has_client(client)) {
        _send_response(fd, ERR_NOTONCHANNEL(channel_name));
        _reply_code = 442;
        return;
    }

    // Remove o cliente do canal
    channel->part(client);

    // Envia uma resposta ao cliente
    _send_response(fd, RPL_PART(client->get_hostname(), channel_name, client->get_nickname()));
    _reply_code = 200;

    // Registra o comando PART recebido
    std::cout << "PART command received from client " << buffer << std::endl;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Invite.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:31:16 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 12:17:23 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"
#include "Channel.hpp"

/*
 * Command: INVITE
 * Parameters: <nickname> <channel>
 * Link: https://datatracker.ietf.org/doc/html/rfc1459#section-4.2.7
 * Example: INVITE Wiz #Twilight_Zone
*/

/**
 * @brief Handles the INVITE command received from the client.
 *
 * This method processes the INVITE command received from the client and sends a response
 * to the client indicating that the client has been invited to the channel.
 *
 * @param buffer The buffer containing the INVITE command parameters.
 * @param fd The file descriptor associated with the client that sent the command.
 */
void Server::_handler_client_invite(const std::string &buffer, const int fd)
{
    // Obtém o cliente associado ao descritor de arquivo (fd)
    Client* client = _get_client(fd);

    // Verifica se o cliente está registrado e autenticado
    if (!client->get_is_logged()) {
        _send_response(fd, ERR_NOTREGISTERED(client->get_nickname()));
        _reply_code = 451;
        return;
    }

    // Divide o buffer em parâmetros
    std::vector<std::string> params = _split_buffer(buffer, " ");
    if (params.size() < 2) {
        _send_response(fd, ERR_NEEDMOREPARAMS(client->get_nickname()));
        _reply_code = 461;
        return;
    }

    // Extrai o apelido do cliente convidado e o nome do canal
    std::string target_nickname = params[0];
    std::string target_channel = params[1];

    // Verifica se o canal existe
    Channel *channel = _get_channel(target_channel);
    if (!channel) {
        _send_response(fd, ERR_NOSUCHCHANNEL(target_channel));
        _reply_code = 403;
        return;
    }

    // Verifica se o cliente está no canal
    if (!channel->has_client(client)) {
        _send_response(fd, ERR_NOTONCHANNEL(target_channel));
        _reply_code = 442;
        return;
    }

    // Verifica se o cliente é um operador do canal
    if (!channel->is_channel_operator(client->get_nickname())) {
        _send_response(fd, ERR_NOPRIVILEGES(client->get_nickname()));
        _reply_code = 481;
        return;
    }

    // Verifica se o cliente convidado existe
    Client *invited_client = _get_client(target_nickname);
    if (!invited_client) {
        _send_response(fd, ERR_NOSUCHNICK(target_channel, target_nickname));
        _reply_code = 401;
        return;
    }

    // Verifica se o cliente convidado já está no canal
    if (channel->has_client(invited_client)) {
        _send_response(fd, ERR_USERONCHANNEL(target_nickname, target_channel));
        _reply_code = 443;
        return;
    }

    // Envia o convite ao cliente convidado
    invited_client->add_channel_invited(target_channel);

    // Envia a resposta de convite ao cliente que enviou o convite
    _send_response(fd, RPL_INVITING(client->get_hostname(), target_channel, client->get_nickname(), target_nickname));
    _reply_code = 200;

    // Registra o comando INVITE recebido
    std::cout << "INVITE command received from client " << buffer << std::endl;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   User.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:32:16 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 22:15:40 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"

#define USER_CMD "USER"

/*
 * Command: USER
 * Parameters: <username>
 * Link: https://datatracker.ietf.org/doc/html/rfc1459#section-4.1.3
*/

/**
 * @brief Handles the USERNAME command received from the client.
 *
 * This method processes the USERNAME command received from the client and sends a response
 * to the client indicating that the client's username has been set.
 *
 * @param username The username to be assigned to the client.
 * @param fd The file descriptor associated with the client that sent the command.
 */
void Server::_handler_client_username(const std::string &buffer, const int fd)
{
    // Registra o comando USER recebido
    std::cout << "USER command received: " << buffer << std::endl;
    
    Client* client = _get_client(fd);
    
    if (buffer.size() < 5) {
        _send_response(fd, ERR_NEEDMOREPARAMS(std::string("*")));
        _reply_code = 461;
    } else if (!client || !client->get_is_authenticated()) {
        _send_response(fd, ERR_NOTREGISTERED(std::string("*")));
        _reply_code = 451;
    } else if (!client->get_username().empty()) {
        _send_response(fd, ERR_ALREADYREGISTERED(client->get_nickname()));
        _reply_code = 462;
    } else {
        client->set_username(buffer);
        if (_client_is_ready_to_login(fd)) {
            client->set_is_logged(fd);
            _send_response(fd, RPL_CONNECTED(client->get_nickname()));
            _reply_code = 001;
        } else {
            _reply_code = 200;
        }
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Quit.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:29:45 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 04:32:42 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"

/*
 * Command: QUIT
 * Parameters: [<Quit message>]
 * Link: https://datatracker.ietf.org/doc/html/rfc1459#section-4.1.6
*/

/**
 * @brief Handles the QUIT command received from the client.
 *
 * This method processes the QUIT command received from the client and sends a response
 * to the client indicating that the client has quit the server.
 *
 * @param buffer The buffer containing the QUIT command parameters.
 * @param fd The file descriptor associated with the client that sent the command.
 */
void Server::_handler_client_quit(const std::string &buffer, const int fd)
{
    (void)buffer;
    _send_response(fd, RPL_QUITMESSAGE(_get_client(fd)->get_nickname()));
    _clear_client(fd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Join.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:33:05 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 22:51:03 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"

/*
 * Command: JOIN
 * Parameters: <channel>{,<channel>} [<key>{,<key>}]
 * Link: https://datatracker.ietf.org/doc/html/rfc1459#section-4.2.1
*/

/**
 * @brief Handles the JOIN command received from the client.
 *
 * This method processes the JOIN command received from the client and sends a response
 * to the client indicating that the client has joined the channel.
 *
 * @param buffer The buffer containing the JOIN command parameters.
 * @param fd The file descriptor associated with the client that sent the command.
 */
void Server::_handler_client_join(const std::string &buffer, const int fd)
{
    Client* client = _get_client(fd);

    if (!client->get_is_logged()) {
        _send_response(fd, ERR_NOTREGISTERED(client->get_nickname()));
        return;
    }

    std::vector<std::string> params = _split_buffer(buffer, SPACE);
    if (params.size() < 1) {
        _send_response(fd, ERR_NEEDMOREPARAMS(client->get_nickname()));
        return;
    }

    std::string joining_channel = params[0];
    if (joining_channel[0] != '#') {
        _send_response(fd, ERR_NOSUCHCHANNEL(joining_channel));
        return;
    }

    Channel *channel = _get_channel(joining_channel);
    if (!channel) {
        // Channel does not exist, create it
        // Se eu estou criando o canal eu devo me incluir e enviar a resposta para o cliente?
        // Quem cria o canal já é moodn então ele é único a adicionar outrs mood e qlqr outra coisa.
        channel = new Channel(joining_channel);
        _add_channel(channel);
        channel->join(client);
        channel->set_channel_operator(client);
        return;
    } else {
        if (channel->has_client(client)) {
            _send_response(fd, ERR_ALREADYREGISTERED(client->get_nickname()));
            return;
        }
    }

    //Verifica se o canal está full e envia mensagem de erro
    if (channel->is_channel_full()) {
        _send_response(fd, ERR_CHANNELISFULL(client->get_nickname(), joining_channel));
        return;
    }

    //TODO: Ygor, não me julgue pelo código criminoso que coloquei abaixo, eu sei que está errado, mas não consegui pensar em outra forma de fazer isso
    // pq estou com sono e não consigo pensar direito, mas amanhã eu arrumamos isso. Eu não testei mas acredito estar funcional...
    // precisa verificar os retornos do servidor para verificar se está tudo ok.

    // Verifica se o canal é apenas para convidados/invitados
    if (channel->is_channel_invite_only()) {
        // Verifica se o cliente tem convite para entrar no canal
        if (!client->is_channel_invited(joining_channel)) {
            _send_response(fd, ERR_INVITEONLYCHAN(client->get_nickname(), joining_channel));
            return;
        } else {
            // O cliente possui o convite, agr precisamos validar se precisa de senha para entrar canal.
            if (channel->has_key()) {
                // Verifica se o cliente tem a senha correta
                if (params.size() < 2) {
                    _send_response(fd, ERR_BADCHANNELKEY(client->get_nickname(), joining_channel));
                    return;
                } else {
                    std::string channel_key = params[1];
                    if (channel_key != channel->get_channel_key()) {
                        _send_response(fd, ERR_BADCHANNELKEY(client->get_nickname(), joining_channel));
                        return;
                    } else {
                        channel->join(client);
                        return;
                    }
                }
            } else {
                channel->join(client);
                return;
            }
        }
    } else {
        channel->join(client);
    }

    // Registra o comando JOIN recebido
    std::cout << "JOIN command received from client " << buffer << std::endl;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Privmsg.cpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:31:33 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 12:19:55 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"
#include "Channel.hpp"
#include "Client.hpp"

/*
 * Command: PRIVMSG
 * Parameters: <receiver>{,<receiver>} <text to be sent>
 * Link: https://datatracker.ietf.org/doc/html/rfc1459#section-4.4.1
*/

#include <vector>
#include <string>
#include <sstream>
#include <utility>


/**
 * @brief Splits a string into tokens based on a delimiter.
 *
 * This function takes a string and a delimiter as input and splits the string into tokens based on the delimiter.
 * The tokens are stored in a vector and returned.
 *
 * @param s The string to be split.
 * @param delimiter The delimiter used to split the string.
 * @return A vector of strings containing the tokens.
 */
std::vector<std::string> split_parameters(const std::string &s, const std::string &delimiter) {
    std::vector<std::string> tokens;
    size_t start = 0;
    size_t end = s.find(delimiter);
    while (end != std::string::npos) {
        tokens.push_back(s.substr(start, end - start));
        start = end + delimiter.length();
        end = s.find(delimiter, start);
    }
    tokens.push_back(s.substr(start, end));
    return tokens;
}

/**
 * @brief Handles the PRIVMSG command received from the client.
 *
 * This method processes the PRIVMSG command received from the client and sends a response
 * to the client indicating that the message has been sent.
 *
 * @param buffer The buffer containing the PRIVMSG command parameters.
 * @param fd The file descriptor associated with the client that sent the command.
 */
void Server::_handler_client_privmsg(const std::string &buffer, const int fd)
{
	Client* client = _get_client(fd);

	std::vector<std::string> params = _split_buffer(buffer, " ");

	std::cout << params[0] << std::endl;
	std::cout << params[1] << std::endl;

	if (client->get_is_logged())
	{
		// Check if the command has the minimum number of parameters
		if (params.size() < 2)
		{
			_send_response(fd, ERR_NEEDMOREPARAMS(client->get_nickname()));
			_reply_code = 461;
			return;
		}
	
		std::vector<std::string> receivers = split_parameters(params[0], ",");

		std::cout << receivers[0] << std::endl;
		
		// Validate channel and client inputs. Otherwise, return an error
		for (std::vector<std::string>::iterator it = receivers.begin(); it != receivers.end(); ++it)
		{
			// Check if first character is #
			if ((*it)[0] == '#')
			{
				// Check if the channel exists
				Channel *target_channel = this->_get_channel(*it);
				if (!target_channel)
				{
					_send_response(fd, ERR_NOSUCHCHANNEL(*it));
					_reply_code = 403;
					return;
				}

				// Check if the client is in the channel
				if (!target_channel->has_client(client))
				{
					_send_response(fd, ERR_NOTONCHANNEL(client->get_nickname()));
					_reply_code = 442;
					return;
				}
			}
			else
			{
				// Check if the receiver exists
				Client *target_client = this->_get_client(*it);
				if (!target_client)
				{
					_send_response(fd, ERR_NOSUCHNICK(std::string(""), client->get_nickname()));
					_reply_code = 401;
					return;
				}
			}
		}

		// Both channels and clients exist, now it's time to send the private message
		for (std::vector<std::string>::iterator it = receivers.begin(); it != receivers.end(); ++it)
		{
			if ((*it)[0] == '#')
			{
				Channel *target_channel = this->_get_channel(*it);
				
				std::cout << "1) THIS IS CHANNEL TARGET:" << target_channel->get_name() << std::endl;
				
				target_channel->broadcast(client, "PRIVMSG", target_channel->get_name(), params[1]);
				
				_send_response(fd, RPL_PRIVMSG(client->get_hostname(), target_channel->get_name(), params[1]));
			}
			else
			{
				// Check if the receiver exists
				Client *target_client = this->_get_client(*it);

				// Send the message to the receiver
				_send_response(target_client->get_fd(), RPL_PRIVMSG(client->get_hostname(), target_client->get_nickname(), params[1]));
			}
		}
	}
	else
	{
		_send_response(fd, ERR_NOTREGISTERED(client->get_nickname()));
		_reply_code = 451;
	}
	//_send_response(fd, RPL_PRIVMSG(client->get_hostname(), "ft_transcendence", "Hello, Carlos!"));
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Nick.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:31:54 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 21:01:56 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"

#define NICK_CMD "NICK"

/*
 * Command: NICK
 * Parameters: <nickname>
 * Reference: https://datatracker.ietf.org/doc/html/rfc1459#section-4.1.2
*/

/**
 * @brief Handles the NICK command received from the client.
 *
 * This method processes the NICK command received from the client and sends a response
 * to the client indicating that the client's nickname has been changed.
 *
 * @param nickname The new nickname to be assigned to the client.
 * @param fd The file descriptor associated with the client that sent the command.
 */
void Server::_handler_client_nickname(const std::string &buffer, const int fd)
{
	// Registra o comando NICK recebido
    std::cout << "NICK command received: " << buffer << std::endl;
	
	Client* client = _get_client(fd);
	
	if (buffer.size() < 5) {
		_send_response(fd, ERR_NEEDMOREPARAMS(std::string("*")));
		_reply_code = 461;
	} else if (!client->get_is_authenticated()) {
		_send_response(fd, ERR_NOTREGISTERED(std::string("*")));
		_reply_code = 451;
	} else if (!_is_valid_nickname(buffer)) {
		_send_response(fd, ERR_ERRONEUSNICK(client->get_nickname()));
		_reply_code = 432;
	} else if (_is_nickname_in_use(fd, buffer)) {
		_send_response(fd, ERR_NICKINUSE(client->get_nickname()));
		_reply_code = 433;
	} else {
		client->set_nickname(buffer);
		if (_client_is_ready_to_login(fd)) {
			client->set_is_logged(fd);
			_send_response(fd, RPL_CONNECTED(client->get_nickname()));
            _reply_code = 001;
		}
		_reply_code = 200;
	}
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Mode.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/21 08:30:34 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 23:00:29 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"

#define MODE_CMD "MODE"

/*
 * Command: MODE
 * Parameters: <channel> {[+|-]|o|p|s|i|t|n|b|v} [<limit>] [<user>]
 * Reference: https://datatracker.ietf.org/doc/html/rfc1459#section-4.2.3
*/

void _handler_invite_only_mode(Channel* channel, bool set);
void _handler_topic_restriction_mode(Channel* channel, bool set);
bool _handler_mode_command(const std::string &modes, char &mode, bool &set);
bool _handler_mode_flags(Channel* channel, Client *client, char mode, bool &set);
void _handle_limit_mode(Channel* channel, const std::string &argument, bool set);
void _handle_operator_privileges_mode(Channel* channel, Client *client, bool set);
void _handle_password_mode(Channel* channel, const std::string &argument, bool set);

/**
 * @brief Handles the MODE command received from the client.
 *
 * This method processes the MODE command received from the client and sends a response
 * to the client indicating the channel modes supported by the server.
 *
 * @param buffer The buffer containing the MODE command parameters.
 * @param fd The file descriptor associated with the client that sent the command.
 */
void Server::_handler_client_mode(const std::string &buffer, const int fd)
{
    // Registra o comando MODE recebido
    std::cout << "MODE command received: " << buffer << std::endl;

    // Separar os argumentos do comando
	bool set;
	char mode = 0;
    std::istringstream iss(buffer);
    std::string chnl, modes, nick;
    iss >> chnl >> modes >> nick;

    Client* client = _get_client(nick);
    Channel* channel = _get_channel(chnl);

	if (!client->get_is_logged()) { // Verificar se o cliente está logado
        _send_response(fd, ERR_NOTREGISTERED(client->get_nickname()));
        _reply_code = 451;
    } else if (chnl.empty() || modes.empty() || nick.empty()) { // Verificar se todos os parâmetros foram fornecidos
        _send_response(fd, ERR_NEEDMOREPARAMS(client->get_nickname()));
        _reply_code = 461;
    } else if (!channel) {
        _send_response(fd, ERR_NOSUCHCHANNEL(chnl));
        _reply_code = 403;
	} else if (!channel->is_channel_operator(nick)) { // Verificar se o cliente tem privilégios de operador no canal
        _send_response(fd, ERR_CHANOPRIVSNEEDED(chnl));
        _reply_code = 482;
    } else { // Tratar o comando MODE
        if (!_handler_mode_command(modes, mode, set)) {
            _send_response(fd, ERR_INVALIDMODEPARM(client->get_nickname(), mode));
            _reply_code = 696;
        }
        else { // Executar a ação correspondente ao modo
            if (_handler_mode_flags(channel, client, mode, set)) {
				_send_response(fd, ERR_UNKNOWNMODE(client->get_nickname(), channel->get_name(), mode));
				_reply_code = 472;
			}
        }
    }
}

bool _handler_mode_flags(Channel* channel, Client *client, char mode, bool &set)
{
	switch (mode) {
		case 'i':
			_handler_invite_only_mode(channel, set);
			break;
		case 't':
			_handler_topic_restriction_mode(channel, set);
			break;
		case 'k':
			_handle_password_mode(channel, client->get_nickname(), set);
			break;
		case 'o':
			_handle_operator_privileges_mode(channel, client, set);
			break;
		case 'l':
			_handle_limit_mode(channel, client->get_nickname(), set);
			break;
		default:
			return false;
	}
    return true;
}

bool _handler_mode_command(const std::string &modes, char &mode, bool &set)
{
	if (modes.size() != 2) {
		return false;
	}
	
    set = (modes[0] == '+');
    mode = modes[1];
	
    return true;
}

void _handler_invite_only_mode(Channel* channel, bool set)
{
	if (set) {
		channel->set_invite_only();
	}
	else {
		channel->set_invite_only();
	}
}

void _handler_topic_restriction_mode(Channel* channel, bool set)
{
	if (set) {
		channel->set_topic_restriction();
	}
	else {
		channel->remove_topic_restriction();
	}
}

void _handle_password_mode(Channel* channel, const std::string &argument, bool set)
{
	if (set) {
		channel->set_key(argument);
	}
	else {
		channel->remove_key();
	}
}

void _handle_operator_privileges_mode(Channel* channel, Client *client, bool set)
{
	if (set) {
		if (client) {
			channel->set_channel_operator(client);
		}
	}
	else {
		if (client) {
			channel->remove_channel_operator(client);
		}
	}
}

void _handle_limit_mode(Channel* channel, const std::string &argument, bool set)
{
	if (set) {
		channel->set_limit(std::atoi(argument.c_str()));
	}
	else {
		channel->remove_limit();
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Bot.cpp                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: caalbert <caalbert@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/27 11:32:28 by caalbert          #+#    #+#             */
/*   Updated: 2024/05/27 11:32:29 by caalbert         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Bot.hpp"
#include <ctime>

void BotCommands::handle_marvin(Server &server, const std::string &buffer, int fd) {
    std::string response = ":Server 001 " + server.get_client(fd)->get_nickname() + " :Olá, sou Marvin, o robô paranóide.";
    server.send_response(fd, response + "\r\n");
}

void BotCommands::handle_time(Server &server, const std::string &buffer, int fd) {
    time_t now = time(NULL);
    std::string time_str = ctime(&now);
    std::string response = ":Server 001 " + server.get_client(fd)->get_nickname() + " :Server time: " + time_str;
    server.send_response(fd, response + "\r\n");
}

void BotCommands::handle_whois(Server &server, const std::string &buffer, int fd) {
    std::istringstream iss(buffer);
    std::string nickname;
    iss >> nickname;
    Client* client = server.get_client(nickname);
    if (client) {
        std::string response = ":Server 311 " + client->get_nickname() + " " + client->get_username() + " " + client->get_ip_address() + " * :Real Name";
        server.send_response(fd, response + "\r\n");
        response = ":Server 318 " + client->get_nickname() + " :End of WHOIS list";
        server.send_response(fd, response + "\r\n");
    } else {
        server.send_response(fd, server.ERR_NOSUCHNICK(nickname) + "\r\n");
    }
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gilmar <gilmar@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/28 10:47:49 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/26 04:32:46 by gilmar           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"

int main(int argc, char **argv)
{
	(void)argc;
	(void)argv;
	Server server;
	// if (argc != 3)
	// 	{std::cout << "Usage: " << argv[0] << " <port number> <password>" << std::endl; return 1;}
	std::cout << "---- SERVER ----" << std::endl;
	server.init("4444", "12345");
	std::cout << "The Server Closed!" << std::endl;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: caalbert <caalbert@student.42sp.org.br>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/28 10:26:55 by gilmar            #+#    #+#             */
/*   Updated: 2024/05/27 19:22:08 by caalbert         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"
#include "Bot.hpp"
#include <sys/socket.h>
#include <cstring>

/*
** ------------------------------- CONSTRUCTOR --------------------------------
*/

Server::Server()
{
	_server_fdsocket = -1;
	_reply_code = 0;
}

/*
** -------------------------------- DESTRUCTOR --------------------------------
*/

Server::~Server()
{
	this->_channels.clear();
	return ;
}

/*
** --------------------------------- METHODS ----------------------------------
*/

/**
 * @brief Initializes the server.
 *
 * This method initializes the server by setting the server port and password,
 * adding the server signal, creating the server socket, and starting the server loop.
 *
 * @param port The server port.
 * @param password The server password.
 *
 * @throws std::invalid_argument if the port is invalid.
 * @throws std::runtime_error if an error occurs during server initialization.
 */
void Server::init(const std::string &port, const std::string &password)
{
	_is_valid_port(port);

	_port = std::atoi(port.c_str());
	_password = password;

	try
	{
		_add_server_signal();
		_set_server_socket();

		std::cout << "Waiting to accept a connection...\n";

		_server_loop();
		_close_fds();
	}
	catch(const std::exception& e)
	{
		_close_fds();
		std::cerr << e.what() << '\n';
	}
}

/**
 * @brief Initializes the server.
 *
 * This method initializes the server by performing the following steps:
 * 1. Creates a server socket.
 * 2. Sets the server address and port.
 * 3. Sets socket options such as SO_REUSEADDR and O_NONBLOCK.
 * 4. Binds the server socket to the specified address and port.
 * 5. Starts listening for incoming connections.
 * 6. Adds the server socket to the pollfd vector for polling.
 * 7. Waits for incoming connections and processes data received from clients.
 *
 * @throws std::runtime_error if any of the initialization steps fail.
 */
void Server::_set_server_socket()
{
	struct pollfd new_poll;
	struct sockaddr_in server_addr;

	int enable = 1; //-> enable the socket option
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = INADDR_ANY;
	server_addr.sin_port = htons(_port); //-> set the port
	_server_fdsocket = socket(AF_INET, SOCK_STREAM, 0); //-> create the socket
	if(_server_fdsocket == -1)
		throw(std::runtime_error("failed to create socket"));
	if(setsockopt(_server_fdsocket, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) == -1) //-> set the socket options | Enable is used to reuse the address
		throw(std::runtime_error("failed to set option (SO_REUSEADDR) on socket"));
	if (fcntl(_server_fdsocket, F_SETFL, O_NONBLOCK) == -1) //-> set the socket to non-blocking mode
		throw(std::runtime_error("failed to set option (O_NONBLOCK) on socket"));
	if (bind(_server_fdsocket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) //-> bind the socket
		throw(std::runtime_error("failed to bind socket"));
	if (listen(_server_fdsocket, SOMAXCONN) == -1) //-> listen for incoming connections
		throw(std::runtime_error("listen() failed"));
	new_poll.fd = _server_fdsocket;
	new_poll.events = POLLIN;
	new_poll.revents = 0;
	_fds.push_back(new_poll);
}

/**
 * @brief Starts the server loop.
 *
 * This method initiates the server loop, continuously waiting for incoming connections
 * and processing data received from clients. It utilizes the poll system call to efficiently
 * monitor file descriptors for events.
 *
 * The server loop continues to run until a termination signal is received.
 *
 * @throws std::runtime_error if an error occurs during the polling process.
 */
void Server::_server_loop()
{
	while (Server::_signal == false)
	{
		// Poll for events on file descriptors
		if((poll(&_fds[0], _fds.size(), -1) == -1) && Server::_signal == false)
			throw(std::runtime_error("poll() faild"));
		for (size_t i = 0; i < _fds.size(); i++) {
			// Check if the file descriptor has an event
			if (_fds[i].revents & POLLIN) {
				if (_fds[i].fd == _server_fdsocket)
					_accept_new_client();
				else
					_receive_new_data(_fds[i].fd);
			}
		}
	}
}

/**
 * @brief Accepts a new client connection.
 *
 * This method is called when a new client connection is detected by the server. It accepts
 * the incoming connection, sets it to non-blocking mode, and adds the client socket to the
 * list of active clients for polling. Additionally, it retrieves the IP address of the client
 * and associates it with the client object.
 *
 * If the acceptance of the new client connection fails or setting the socket to non-blocking mode
 * fails, appropriate error messages are printed to the standard output, and the function returns.
 */
void Server::_accept_new_client()
{
	Client cli; //-> create a new client
	struct pollfd new_poll; //-> create a new pollfd
	struct sockaddr_in cli_addr;  //-> create a new sockaddr_in

	memset(&cli_addr, 0, sizeof(cli_addr));
	socklen_t len = sizeof(cli_addr);
	int incofd = accept(_server_fdsocket, (sockaddr *)&(cli_addr), &len); // -> accept the incoming connection
	if (incofd == -1)
		{std::cout << "accept() failed" << std::endl; return;}
	if (fcntl(incofd, F_SETFL, O_NONBLOCK) == -1) //-> set the socket to non-blocking mode
		{std::cout << "fcntl() failed" << std::endl; return;}
	new_poll.fd = incofd; //-> set the file descriptor
	new_poll.events = POLLIN; //-> set the events
	new_poll.revents = 0;
	cli.set_fd(incofd); //-> set the file descriptor
	cli.set_ip_add(inet_ntoa((cli_addr.sin_addr))); //-> set the ip address
	_clients.push_back(cli);
	_fds.push_back(new_poll);
	std::cout << GRE << "Client <" << incofd << "> Connected" << WHI << std::endl;
}

void Server::_receive_new_data(const int fd)
{
	char buffer[1024]; //-> buffer for the received data
	std::memset(buffer, 0, sizeof(buffer)); //-> clear the buffer

	Client* cli = _get_client(fd); // -> get the client object associated with the file descriptor (fd)
	ssize_t bytes = recv(fd, buffer, sizeof(buffer) -1 , 0); //-> receive the data
	if(bytes <= 0) { //-> check if the client disconnected
		std::cout << RED << "Client <" << fd << "> Disconnected" << WHI << std::endl;
		_clear_client(fd); //-> clear the client
	}
	else {
		cli->set_buffer(buffer); //-> set the buffer with the received data
		if (cli->get_buffer().find_first_of(LINE_FEED) == std::string::npos) //-> check if the data is complete
			return;
		_execute_command(cli->get_buffer(), fd); //-> execute the command
	}
}


/**
 * @brief List of commands and their corresponding handlers.
 *
 * This list contains the commands supported by the server and their corresponding handler functions.
 * Each entry in the list consists of a command string and a pointer to the handler function for that command.
 * The handler functions are responsible for processing the command and executing the corresponding action.
 */
const Server::command_handler Server::_command_list[_command_list_size] = {
	{"JOIN", &Server::_handler_client_join},
	{"QUIT", &Server::_handler_client_quit},
	{"PART", &Server::_handler_client_part},
	{"MODE", &Server::_handler_client_mode},
	{"KICK", &Server::_handler_client_kick},
	{"TOPIC", &Server::_handler_client_topic},
	{"NICK", &Server::_handler_client_nickname},
	{"USER", &Server::_handler_client_username},
	{"PASS", &Server::_handler_client_password},
	{"INVITE", &Server::_handler_client_invite},
	{"PRIVMSG", &Server::_handler_client_privmsg},
    {"MARVIN", &Server::_handle_marvin},
    {"TIME", &Server::_handle_time},
    {"WHOIS", &Server::_handle_whois},
};

/**
 * @brief Executes the command received from the client.
 *
 * This method processes the command received from the client and executes the corresponding action.
 * It parses the received buffer into individual commands and iterates through each command to execute
 * the corresponding action. The method is responsible for handling various commands such as authentication,
 * message sending, and other server operations.
 *
 * @param command The received buffer containing the command to be executed.
 * @param fd The file descriptor associated with the client that sent the command.
 */
void Server::_execute_command(const std::string buffer, const int fd)
{
	if (buffer.empty())
		return ;
	std::string clean_buffer = _cleanse_buffer(buffer, CRLF);
	std::vector<std::string> splitted_buffer = _split_buffer(clean_buffer, DELIMITER);
	if (splitted_buffer.empty())
		return ;
	std::string command = toupper(splitted_buffer[0]);
	std::string parameters = splitted_buffer[1];

	//TODO: Add a default handler for unknown commands
	for (size_t i = 0; i < _command_list_size; i++) {
		if (command == _command_list[i].command) {
			(this->*_command_list[i].handler)(parameters, fd);
			break;
		}
	}
}



/*
** ------------------------------- PARSER COMMAND --------------------------------
*/

/**
 * @brief Splits a buffer into tokens using a specified delimiter.
 *
 * This method splits the original string into tokens using the specified delimiter.
 * It searches for the delimiter in the original string and splits the string into tokens
 * based on the delimiter. The tokens are stored in a vector and returned.
 *
 * @param buffer The original string to be split.
 * @param delimiter The delimiter used to split the string.
 *
 * @return A vector containing the tokens obtained by splitting the original string.
 */
std::vector<std::string> Server::_split_buffer(const std::string &buffer, const std::string &delimiter)
{
    std::string command;
    std::string parameters;
    std::vector<std::string> tokens;
    std::istringstream iss(buffer);


    iss >> command;
    tokens.push_back(command);

    std::getline(iss >> std::ws, parameters);
    parameters.erase(0, parameters.find_first_not_of(delimiter));
    tokens.push_back(parameters);

    return tokens;
}

/**
 * @brief Cleanses a buffer by removing specified characters.
 *
 * This method removes specified characters from the original string and returns the cleaned string.
 * The characters to be removed are specified by the `chars_to_remove` parameter.
 *
 * The function searches for the first occurrence of any character specified in `chars_to_remove`
 * in the original string `original_str`, and truncates the string up to that point, excluding the found character.
 *
 * @param buffer The original string to be cleansed.
 * @param chars_to_remove A string containing the characters to be removed.
 * @return A string containing the original string with specified characters removed.
 *
 * @note This function assumes that `original_str` is not empty and contains at least one character to be removed.
 *       If `chars_to_remove` is empty, the function returns the original string without any changes.
 */
std::string Server::_cleanse_buffer(const std::string &buffer, const std::string &chars_to_remove)
{
	std::string clean_buffer;

	size_t pos = buffer.find_first_of(chars_to_remove);
	if (pos != std::string::npos)
		clean_buffer = buffer.substr(0, pos);
	else
		clean_buffer = buffer;
	return clean_buffer;
}

/*
** ------------------------------- CLEAR FUCTIONS --------------------------------
*/

/**
 * @brief Closes all file descriptors associated with the server.
 *
 * This method closes all file descriptors associated with the server, including client connections
 * and the server socket itself. It iterates through the list of client connections, closing each
 * client socket individually. After that, it closes the server socket if it is valid.
 *
 * Upon closing each client connection and the server socket, it prints a message indicating the
 * disconnection to the standard output.
 */
void Server::_close_fds()
{
	//-> close all the clients
	for(size_t i = 0; i < _clients.size(); i++) {
		std::cout << RED << "Client <" << _clients[i].get_fd() << "> Disconnected" << WHI << std::endl;
		close(_clients[i].get_fd());
	}
	if (_server_fdsocket != -1) {
		std::cout << RED << "Server <" << _server_fdsocket << "> Disconnected" << WHI << std::endl;
		close(_server_fdsocket);
	}
}

/**
 * @brief Clears the client associated with the given file descriptor.
 *
 * This method removes the client with the specified file descriptor from the list of file descriptors
 * being polled (_fds) and from the vector of active clients (_clients). Additionally, it closes the
 * client socket.
 *
 * @param fd The file descriptor associated with the client to be cleared.
 */
void Server::_clear_client(const int fd)
{
	for(size_t i = 0; i < _fds.size(); i++) { //-> Remove the client from the pollfd
		if (_fds[i].fd == fd){
			_fds.erase(_fds.begin() + i);
			break;
		}
	}
	for(size_t i = 0; i < _clients.size(); i++) { //-> Remove the client from the vector of clients
		if (_clients[i].get_fd() == fd) {
			_clients.erase(_clients.begin() + i);
			break;
		}
	}
	close(fd);
}

/*
** ------------------------------- SIGNAL FUCTIONS --------------------------------
*/

/**
 * @brief Signal handler function for the server.
 *
 * This function is called when a signal is received by the server process. It handles the signal
 * specified by the `signum` parameter. In this implementation, the function simply prints a message
 * indicating that a signal has been received and sets the static boolean variable `_signal` to true.
 * This variable is used to control the server loop and stop the server gracefully.
 *
 * @param signum The signal number that triggered the signal handler.
 */
bool Server::_signal = false; //-> initialize the static boolean
void Server::_signal_handler(const int signum)
{
	(void)signum;
	std::cout << std::endl << "Signal Received!" << std::endl;
	Server::_signal = true; //-> set the static boolean to true to stop the server
}

/**
 * @brief Adds signal handlers for the server.
 *
 * This method sets up signal handlers for the server to catch specific signals, such as SIGINT
 * (generated by pressing Ctrl+C) and SIGQUIT (generated by pressing Ctrl+\). When any of these
 * signals are received, the corresponding signal handler function Server::_signal_handler is invoked.
 */
void Server::_add_server_signal()
{
	signal(SIGINT, Server::_signal_handler); //-> catch the signal (ctrl + c)
	signal(SIGQUIT, Server::_signal_handler); //-> catch the signal (ctrl + \)
}

/*
** ------------------------------- VALIDATIONS FUCTIONS --------------------------------
*/

/**
 * @brief Checks if the port is valid.
 *
 * This method verifies whether the provided port is valid by performing the following checks:
 * 1. Ensures that the port consists only of numeric characters.
 * 2. Validates that the port number falls within the range of valid port numbers (1024 - 65535).
 *
 * @param port The port to check represented as a string.
 * @throws std::invalid_argument if the port is invalid (contains non-numeric characters or is out of range).
 */
void Server::_is_valid_port(const std::string &port)
{
	if (!(port.find_first_not_of("0123456789") == std::string::npos && \
		std::atoi(port.c_str()) >= 1024 && std::atoi(port.c_str()) <= 65535))
	{
		throw std::invalid_argument("Invalid port: either contains non-numeric characters or is out of range");
	}
}

/**
 * @brief Checks if the nickname is valid.
 *
 * This method verifies whether the provided nickname is valid by performing the following checks:
 * 1. Ensures that the nickname is at least 6 characters long.
 * 2. Validates that the nickname contains only alphanumeric characters.
 *
 * @param nickname The nickname to check.
 * @return true if the nickname is valid, false otherwise.
 */
bool Server::_is_valid_nickname(const std::string &nickname)
{
	if (nickname.size() <= 5)
		return false;
	for (std::string::const_iterator it = nickname.begin(); it != nickname.end(); ++it) {
		if (!std::isalnum(*it))
			return false;
	}
	return true;
}

/**
 * @brief Checks if the nickname is already in use.
 *
 * This method checks if the provided nickname is already in use by another client. It iterates
 * through the list of active clients and compares the provided nickname with the nicknames of
 * other clients. If a match is found, the method returns true, indicating that the nickname is in use.
 *
 * @param fd The file descriptor associated with the client.
 * @param username The nickname to check.
 * @return true if the nickname is in use, false otherwise.
 */
bool Server::_is_nickname_in_use(const int fd, const std::string &username)
{
	for (std::vector<Client>::iterator it = _clients.begin(); it != _clients.end(); ++it) {
		if (it->get_nickname() == username && it->get_fd() == fd)
			return true;
	}
	return false;
}

/*
** ------------------------------- CLIENT FUCTIONS --------------------------------
*/

/**
 * @brief Retrieves the client associated with the given file descriptor.
 *
 * This method retrieves the client object associated with the specified file descriptor from the
 * vector of active clients. It iterates through the list of clients and returns the client object
 * that matches the provided file descriptor.
 *
 * @param fd The file descriptor associated with the client to retrieve.
 * @return The client object associated with the specified file descriptor.
 */
Client* Server::_get_client(const int fd)
{
	for (size_t i = 0; i < _clients.size(); i++) {
		if (_clients[i].get_fd() == fd) {
			return &_clients[i];
		}
	}
	return NULL;
}

Client* Server::_get_client(const std::string nickname)
{
	for (size_t i = 0; i < _clients.size(); i++) {
		if (_clients[i].get_nickname() == nickname) {
			return &_clients[i];
		}
	}
	// return null and verify if client exists
	return NULL;
	//throw std::invalid_argument("Client not found");
}

bool Server::_client_is_ready_to_login(const int fd)
{
	Client *client = _get_client(fd);

	if (!client->get_username().empty() && !client->get_nickname().empty() && !client->get_is_logged())
		return true;
	return false;
}

/*
** ------------------------------- UTILS FUCTIONS --------------------------------
*/

/**
 * @brief Sends a response to the client.
 *
 * This method sends a response to the client associated with the specified file descriptor.
 * It sends the response message to the client socket using the send system call.
 *
 * @param fd The file descriptor associated with the client to send the response.
 * @param response The response message to send to the client.
 */
void Server::_send_response(const int fd, const std::string &response)
{
	std::cout << "Response:\n" << response;
	if(send(fd, response.c_str(), response.size(), 0) == -1)
		std::cerr << "Response send() failed" << std::endl;
}

/**
 * @brief Converts a string to uppercase.
 *
 * This method converts the provided string to uppercase by iterating through each character
 * in the string and converting it to its uppercase equivalent using the std::toupper function.
 *
 * @param str The string to convert to uppercase.
 * @return The converted string in uppercase.
 */
std::string Server::toupper(const std::string& str)
{
	std::string result = str;
	for (size_t i = 0; i < result.length(); ++i) {
		result[i] = std::toupper(result[i]);
	}
	return result;
}

/*
** ------------------------------- CHANNEL FUCTIONS --------------------------------
*/
Channel* Server::_get_channel(const std::string &channel_name)
{
	for (size_t i = 0; i < _channels.size(); i++) {
		if (_channels[i]->get_name() == channel_name) {
			return _channels[i];
		}
	}
	return NULL;
}

void Server::_add_channel(Channel *channel)
{
	_channels.push_back(channel);
}

int Server::get_reply_code(void)
{
	return _reply_code;
}

Client* Server::get_client(int fd) {
	for (size_t i = 0; i < _clients.size(); ++i) {
		if (_clients[i].get_fd() == fd) {
			return &_clients[i];
		}
	}
	return nullptr;
}

void Server::send_response(int fd, const std::string& message) {
	if (send(fd, message.c_str(), message.size(), 0) < 0) {
		perror("send failed");
	}
}

Client* Server::get_client_by_nickname(const std::string& nickname) {
for (auto& client : _clients) {
	if (client.get_nickname() == nickname) {
		return &client;
	}
}
return nullptr;
}

/*
** ------------------------------- COMMAND HANDLERS --------------------------------
*/

void Server::_handle_marvin(const std::string &/* buffer */, int fd) {
	std::string response = ":Server 001 " + this->get_client(fd)->get_nickname() + " :Olá, sou Marvin, o robô paranóide.";
	this->send_response(fd, response + "\r\n");
}

void Server::_handle_time(const std::string &/* buffer */, int fd) {
	time_t now = time(NULL);
	std::string time_str = ctime(&now);
	std::string response = ":Server 001 " + this->get_client(fd)->get_nickname() + " :Server time: " + time_str;
	this->send_response(fd, response + "\r\n");
}

void Server::_handle_whois(const std::string &/* buffer */, int fd) {
	std::string nickname; // Deve ser extraído de buffer como necessário
	Client* client = this->get_client_by_nickname(nickname);
	if (client) {
		std::string response = ":Server 311 " + client->get_nickname() + " " + client->get_username() + " " + client->get_ip_address() + " * :Real Name";
		this->send_response(fd, response + "\r\n");
		response = ":Server 318 " + client->get_nickname() + " :End of WHOIS list";
		this->send_response(fd, response + "\r\n");
	} else {
		this->send_response(fd, ERR_NOSUCHNICK("Server", nickname) + "\r\n");
	}
}

